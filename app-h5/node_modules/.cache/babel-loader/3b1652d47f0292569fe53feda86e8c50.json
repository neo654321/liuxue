{"ast":null,"code":"// Process footnotes\n//\n'use strict';\n\n////////////////////////////////////////////////////////////////////////////////\n// Renderer partials\nrequire(\"core-js/modules/es.array.push.js\");\nfunction _footnote_ref(tokens, idx) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n}\nfunction _footnote_block_open(tokens, idx, options) {\n  return (options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n') + '<section class=\"footnotes\">\\n' + '<ol class=\"footnotes-list\">\\n';\n}\nfunction _footnote_block_close() {\n  return '</ol>\\n</section>\\n';\n}\nfunction _footnote_open(tokens, idx) {\n  var id = Number(tokens[idx].meta.id + 1).toString();\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n}\nfunction _footnote_close() {\n  return '</li>\\n';\n}\nfunction _footnote_anchor(tokens, idx) {\n  var n = Number(tokens[idx].meta.id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].meta.subId > 0) {\n    id += ':' + tokens[idx].meta.subId;\n  }\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">\\u21a9</a>'; /* â†© */\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmodule.exports = function sub_plugin(md) {\n  var parseLinkLabel = md.helpers.parseLinkLabel,\n    isSpace = md.utils.isSpace;\n  md.renderer.rules.footnote_ref = _footnote_ref;\n  md.renderer.rules.footnote_block_open = _footnote_block_open;\n  md.renderer.rules.footnote_block_close = _footnote_block_close;\n  md.renderer.rules.footnote_open = _footnote_open;\n  md.renderer.rules.footnote_close = _footnote_close;\n  md.renderer.rules.footnote_anchor = _footnote_anchor;\n\n  // Process footnote block definition\n  function footnote_def(state, startLine, endLine, silent) {\n    var oldBMark,\n      oldTShift,\n      oldSCount,\n      oldParentType,\n      pos,\n      label,\n      token,\n      initial,\n      offset,\n      ch,\n      posAfterColon,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n    // line should be at least 5 chars - \"[^x]:\"\n    if (start + 4 > max) {\n      return false;\n    }\n    if (state.src.charCodeAt(start) !== 0x5B /* [ */) {\n      return false;\n    }\n    if (state.src.charCodeAt(start + 1) !== 0x5E /* ^ */) {\n      return false;\n    }\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n    if (pos === start + 2) {\n      return false;\n    } // no empty footnote labels\n    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) {\n      return false;\n    }\n    if (silent) {\n      return true;\n    }\n    pos++;\n    if (!state.env.footnotes) {\n      state.env.footnotes = {};\n    }\n    if (!state.env.footnotes.refs) {\n      state.env.footnotes.refs = {};\n    }\n    label = state.src.slice(start + 2, pos - 2);\n    state.env.footnotes.refs[':' + label] = -1;\n    token = new state.Token('footnote_reference_open', '', 1);\n    token.meta = {\n      label: label\n    };\n    token.level = state.level++;\n    state.tokens.push(token);\n    oldBMark = state.bMarks[startLine];\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n    oldParentType = state.parentType;\n    posAfterColon = pos;\n    initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n      } else {\n        break;\n      }\n      pos++;\n    }\n    state.tShift[startLine] = pos - posAfterColon;\n    state.sCount[startLine] = offset - initial;\n    state.bMarks[startLine] = posAfterColon;\n    state.blkIndent += 4;\n    state.parentType = 'footnote';\n    if (state.sCount[startLine] < state.blkIndent) {\n      state.sCount[startLine] += state.blkIndent;\n    }\n    state.md.block.tokenize(state, startLine, endLine, true);\n    state.parentType = oldParentType;\n    state.blkIndent -= 4;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.bMarks[startLine] = oldBMark;\n    token = new state.Token('footnote_reference_close', '', -1);\n    token.level = --state.level;\n    state.tokens.push(token);\n    return true;\n  }\n\n  // Process inline footnotes (^[...])\n  function footnote_inline(state, silent) {\n    var labelStart,\n      labelEnd,\n      footnoteId,\n      token,\n      tokens,\n      max = state.posMax,\n      start = state.pos;\n    if (start + 2 >= max) {\n      return false;\n    }\n    if (state.src.charCodeAt(start) !== 0x5E /* ^ */) {\n      return false;\n    }\n    if (state.src.charCodeAt(start + 1) !== 0x5B /* [ */) {\n      return false;\n    }\n    labelStart = start + 2;\n    labelEnd = parseLinkLabel(state, start + 1);\n\n    // parser failed to find ']', so it's not a valid note\n    if (labelEnd < 0) {\n      return false;\n    }\n\n    // We found the end of the link, and know for a fact it's a valid link;\n    // so all that's left to do is to call tokenizer.\n    //\n    if (!silent) {\n      if (!state.env.footnotes) {\n        state.env.footnotes = {};\n      }\n      if (!state.env.footnotes.list) {\n        state.env.footnotes.list = [];\n      }\n      footnoteId = state.env.footnotes.list.length;\n      state.md.inline.parse(state.src.slice(labelStart, labelEnd), state.md, state.env, tokens = []);\n      token = state.push('footnote_ref', '', 0);\n      token.meta = {\n        id: footnoteId\n      };\n      state.env.footnotes.list[footnoteId] = {\n        tokens: tokens\n      };\n    }\n    state.pos = labelEnd + 1;\n    state.posMax = max;\n    return true;\n  }\n\n  // Process footnote references ([^...])\n  function footnote_ref(state, silent) {\n    var label,\n      pos,\n      footnoteId,\n      footnoteSubId,\n      token,\n      max = state.posMax,\n      start = state.pos;\n\n    // should be at least 4 chars - \"[^x]\"\n    if (start + 3 > max) {\n      return false;\n    }\n    if (!state.env.footnotes || !state.env.footnotes.refs) {\n      return false;\n    }\n    if (state.src.charCodeAt(start) !== 0x5B /* [ */) {\n      return false;\n    }\n    if (state.src.charCodeAt(start + 1) !== 0x5E /* ^ */) {\n      return false;\n    }\n    for (pos = start + 2; pos < max; pos++) {\n      if (state.src.charCodeAt(pos) === 0x20) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos) === 0x0A) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n        break;\n      }\n    }\n    if (pos === start + 2) {\n      return false;\n    } // no empty footnote labels\n    if (pos >= max) {\n      return false;\n    }\n    pos++;\n    label = state.src.slice(start + 2, pos - 1);\n    if (typeof state.env.footnotes.refs[':' + label] === 'undefined') {\n      return false;\n    }\n    if (!silent) {\n      if (!state.env.footnotes.list) {\n        state.env.footnotes.list = [];\n      }\n      if (state.env.footnotes.refs[':' + label] < 0) {\n        footnoteId = state.env.footnotes.list.length;\n        state.env.footnotes.list[footnoteId] = {\n          label: label,\n          count: 0\n        };\n        state.env.footnotes.refs[':' + label] = footnoteId;\n      } else {\n        footnoteId = state.env.footnotes.refs[':' + label];\n      }\n      footnoteSubId = state.env.footnotes.list[footnoteId].count;\n      state.env.footnotes.list[footnoteId].count++;\n      token = state.push('footnote_ref', '', 0);\n      token.meta = {\n        id: footnoteId,\n        subId: footnoteSubId\n      };\n    }\n    state.pos = pos;\n    state.posMax = max;\n    return true;\n  }\n\n  // Glue footnote tokens to end of token stream\n  function footnote_tail(state) {\n    var i,\n      l,\n      j,\n      t,\n      lastParagraph,\n      list,\n      token,\n      tokens,\n      current,\n      currentLabel,\n      insideRef = false,\n      refTokens = {};\n    if (!state.env.footnotes) {\n      return;\n    }\n    state.tokens = state.tokens.filter(function (tok) {\n      if (tok.type === 'footnote_reference_open') {\n        insideRef = true;\n        current = [];\n        currentLabel = tok.meta.label;\n        return false;\n      }\n      if (tok.type === 'footnote_reference_close') {\n        insideRef = false;\n        // prepend ':' to avoid conflict with Object.prototype members\n        refTokens[':' + currentLabel] = current;\n        return false;\n      }\n      if (insideRef) {\n        current.push(tok);\n      }\n      return !insideRef;\n    });\n    if (!state.env.footnotes.list) {\n      return;\n    }\n    list = state.env.footnotes.list;\n    token = new state.Token('footnote_block_open', '', 1);\n    state.tokens.push(token);\n    for (i = 0, l = list.length; i < l; i++) {\n      token = new state.Token('footnote_open', '', 1);\n      token.meta = {\n        id: i\n      };\n      state.tokens.push(token);\n      if (list[i].tokens) {\n        tokens = [];\n        token = new state.Token('paragraph_open', 'p', 1);\n        token.block = true;\n        tokens.push(token);\n        token = new state.Token('inline', '', 0);\n        token.children = list[i].tokens;\n        token.content = '';\n        tokens.push(token);\n        token = new state.Token('paragraph_close', 'p', -1);\n        token.block = true;\n        tokens.push(token);\n      } else if (list[i].label) {\n        tokens = refTokens[':' + list[i].label];\n      }\n      state.tokens = state.tokens.concat(tokens);\n      if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n        lastParagraph = state.tokens.pop();\n      } else {\n        lastParagraph = null;\n      }\n      t = list[i].count > 0 ? list[i].count : 1;\n      for (j = 0; j < t; j++) {\n        token = new state.Token('footnote_anchor', '', 0);\n        token.meta = {\n          id: i,\n          subId: j\n        };\n        state.tokens.push(token);\n      }\n      if (lastParagraph) {\n        state.tokens.push(lastParagraph);\n      }\n      token = new state.Token('footnote_close', '', -1);\n      state.tokens.push(token);\n    }\n    token = new state.Token('footnote_block_close', '', -1);\n    state.tokens.push(token);\n  }\n  md.block.ruler.before('reference', 'footnote_def', footnote_def, {\n    alt: ['paragraph', 'reference']\n  });\n  md.inline.ruler.after('image', 'footnote_inline', footnote_inline);\n  md.inline.ruler.after('footnote_inline', 'footnote_ref', footnote_ref);\n  md.core.ruler.after('inline', 'footnote_tail', footnote_tail);\n};","map":null,"metadata":{},"sourceType":"script"}