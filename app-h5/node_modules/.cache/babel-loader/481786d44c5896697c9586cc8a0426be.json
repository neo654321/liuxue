{"ast":null,"code":"require(\"core-js/modules/es.array.slice.js\");\nrequire(\"core-js/modules/es.array.splice.js\");\n/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n */\n\nvar utils = require(\"./utils\");\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove null or empty classes.\n */\nvar createClass = function createClass(classes) {\n  classes = classes.slice();\n  for (var i = classes.length - 1; i >= 0; i--) {\n    if (!classes[i]) {\n      classes.splice(i, 1);\n    }\n  }\n  return classes.join(\" \");\n};\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n */\nfunction span(classes, children, height, depth, maxFontSize, style) {\n  this.classes = classes || [];\n  this.children = children || [];\n  this.height = height || 0;\n  this.depth = depth || 0;\n  this.maxFontSize = maxFontSize || 0;\n  this.style = style || {};\n  this.attributes = {};\n}\n\n/**\n * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all\n * browsers support attributes the same, and having too many custom attributes\n * is probably bad.\n */\nspan.prototype.setAttribute = function (attribute, value) {\n  this.attributes[attribute] = value;\n};\n\n/**\n * Convert the span into an HTML node\n */\nspan.prototype.toNode = function () {\n  var span = document.createElement(\"span\");\n\n  // Apply the class\n  span.className = createClass(this.classes);\n\n  // Apply inline styles\n  for (var style in this.style) {\n    if (Object.prototype.hasOwnProperty.call(this.style, style)) {\n      span.style[style] = this.style[style];\n    }\n  }\n\n  // Apply attributes\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      span.setAttribute(attr, this.attributes[attr]);\n    }\n  }\n\n  // Append the children, also as HTML nodes\n  for (var i = 0; i < this.children.length; i++) {\n    span.appendChild(this.children[i].toNode());\n  }\n  return span;\n};\n\n/**\n * Convert the span into an HTML markup string\n */\nspan.prototype.toMarkup = function () {\n  var markup = \"<span\";\n\n  // Add the class\n  if (this.classes.length) {\n    markup += \" class=\\\"\";\n    markup += utils.escape(createClass(this.classes));\n    markup += \"\\\"\";\n  }\n  var styles = \"\";\n\n  // Add the styles, after hyphenation\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  }\n\n  // Add the attributes\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      markup += \" \" + attr + \"=\\\"\";\n      markup += utils.escape(this.attributes[attr]);\n      markup += \"\\\"\";\n    }\n  }\n  markup += \">\";\n\n  // Add the markup of the children, also as markup\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n  markup += \"</span>\";\n  return markup;\n};\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. Thus, it only\n * contains children and doesn't have any HTML properties. It also keeps track\n * of a height, depth, and maxFontSize.\n */\nfunction documentFragment(children, height, depth, maxFontSize) {\n  this.children = children || [];\n  this.height = height || 0;\n  this.depth = depth || 0;\n  this.maxFontSize = maxFontSize || 0;\n}\n\n/**\n * Convert the fragment into a node\n */\ndocumentFragment.prototype.toNode = function () {\n  // Create a fragment\n  var frag = document.createDocumentFragment();\n\n  // Append the children\n  for (var i = 0; i < this.children.length; i++) {\n    frag.appendChild(this.children[i].toNode());\n  }\n  return frag;\n};\n\n/**\n * Convert the fragment into HTML markup\n */\ndocumentFragment.prototype.toMarkup = function () {\n  var markup = \"\";\n\n  // Simply concatenate the markup for the children together\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n  return markup;\n};\n\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\nfunction symbolNode(value, height, depth, italic, skew, classes, style) {\n  this.value = value || \"\";\n  this.height = height || 0;\n  this.depth = depth || 0;\n  this.italic = italic || 0;\n  this.skew = skew || 0;\n  this.classes = classes || [];\n  this.style = style || {};\n  this.maxFontSize = 0;\n}\n\n/**\n * Creates a text node or span from a symbol node. Note that a span is only\n * created if it is needed.\n */\nsymbolNode.prototype.toNode = function () {\n  var node = document.createTextNode(this.value);\n  var span = null;\n  if (this.italic > 0) {\n    span = document.createElement(\"span\");\n    span.style.marginRight = this.italic + \"em\";\n  }\n  if (this.classes.length > 0) {\n    span = span || document.createElement(\"span\");\n    span.className = createClass(this.classes);\n  }\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      span = span || document.createElement(\"span\");\n      span.style[style] = this.style[style];\n    }\n  }\n  if (span) {\n    span.appendChild(node);\n    return span;\n  } else {\n    return node;\n  }\n};\n\n/**\n * Creates markup for a symbol node.\n */\nsymbolNode.prototype.toMarkup = function () {\n  // TODO(alpert): More duplication than I'd like from\n  // span.prototype.toMarkup and symbolNode.prototype.toNode...\n  var needsSpan = false;\n  var markup = \"<span\";\n  if (this.classes.length) {\n    needsSpan = true;\n    markup += \" class=\\\"\";\n    markup += utils.escape(createClass(this.classes));\n    markup += \"\\\"\";\n  }\n  var styles = \"\";\n  if (this.italic > 0) {\n    styles += \"margin-right:\" + this.italic + \"em;\";\n  }\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n  if (styles) {\n    needsSpan = true;\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  }\n  var escaped = utils.escape(this.value);\n  if (needsSpan) {\n    markup += \">\";\n    markup += escaped;\n    markup += \"</span>\";\n    return markup;\n  } else {\n    return escaped;\n  }\n};\nmodule.exports = {\n  span: span,\n  documentFragment: documentFragment,\n  symbolNode: symbolNode\n};","map":null,"metadata":{},"sourceType":"script"}