{"ast":null,"code":"// Process definition lists\n//\n'use strict';\n\nrequire(\"core-js/modules/es.array.map.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.string.trim.js\");\nmodule.exports = function deflist_plugin(md) {\n  var isSpace = md.utils.isSpace;\n\n  // Search `[:~][\\n ]`, returns next pos after marker on success\n  // or -1 on fail.\n  function skipMarker(state, line) {\n    var pos,\n      marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n    if (start >= max) {\n      return -1;\n    }\n\n    // Check bullet\n    marker = state.src.charCodeAt(start++);\n    if (marker !== 0x7E /* ~ */ && marker !== 0x3A /* : */) {\n      return -1;\n    }\n    pos = state.skipSpaces(start);\n\n    // require space after \":\"\n    if (start === pos) {\n      return -1;\n    }\n\n    // no empty definitions, e.g. \"  : \"\n    if (pos >= max) {\n      return -1;\n    }\n    return start;\n  }\n  function markTightParagraphs(state, idx) {\n    var i,\n      l,\n      level = state.level + 2;\n    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n      if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n        state.tokens[i + 2].hidden = true;\n        state.tokens[i].hidden = true;\n        i += 2;\n      }\n    }\n  }\n  function deflist(state, startLine, endLine, silent) {\n    var ch, contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, max, nextLine, offset, oldDDIndent, oldIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, prevEmptyEnd, tight, token;\n    if (silent) {\n      // quirk: validation mode validates a dd block only, not a whole deflist\n      if (state.ddIndent < 0) {\n        return false;\n      }\n      return skipMarker(state, startLine) >= 0;\n    }\n    nextLine = startLine + 1;\n    if (nextLine >= endLine) {\n      return false;\n    }\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        return false;\n      }\n    }\n    if (state.sCount[nextLine] < state.blkIndent) {\n      return false;\n    }\n    contentStart = skipMarker(state, nextLine);\n    if (contentStart < 0) {\n      return false;\n    }\n\n    // Start list\n    listTokIdx = state.tokens.length;\n    tight = true;\n    token = state.push('dl_open', 'dl', 1);\n    token.map = listLines = [startLine, 0];\n\n    //\n    // Iterate list items\n    //\n\n    dtLine = startLine;\n    ddLine = nextLine;\n\n    // One definition list can contain multiple DTs,\n    // and one DT can be followed by multiple DDs.\n    //\n    // Thus, there is two loops here, and label is\n    // needed to break out of the second one\n    //\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER: for (;;) {\n      prevEmptyEnd = false;\n      token = state.push('dt_open', 'dt', 1);\n      token.map = [dtLine, dtLine];\n      token = state.push('inline', '', 0);\n      token.map = [dtLine, dtLine];\n      token.content = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim();\n      token.children = [];\n      token = state.push('dt_close', 'dt', -1);\n      for (;;) {\n        token = state.push('dd_open', 'dd', 1);\n        token.map = itemLines = [nextLine, 0];\n        pos = contentStart;\n        max = state.eMarks[ddLine];\n        offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine]);\n        while (pos < max) {\n          ch = state.src.charCodeAt(pos);\n          if (isSpace(ch)) {\n            if (ch === 0x09) {\n              offset += 4 - offset % 4;\n            } else {\n              offset++;\n            }\n          } else {\n            break;\n          }\n          pos++;\n        }\n        contentStart = pos;\n        oldTight = state.tight;\n        oldDDIndent = state.ddIndent;\n        oldIndent = state.blkIndent;\n        oldTShift = state.tShift[ddLine];\n        oldSCount = state.sCount[ddLine];\n        oldParentType = state.parentType;\n        state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;\n        state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n        state.sCount[ddLine] = offset;\n        state.tight = true;\n        state.parentType = 'deflist';\n        state.md.block.tokenize(state, ddLine, endLine, true);\n\n        // If any of list item is tight, mark list as tight\n        if (!state.tight || prevEmptyEnd) {\n          tight = false;\n        }\n        // Item become loose if finish with empty line,\n        // but we should filter last element, because it means list finish\n        prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n        state.tShift[ddLine] = oldTShift;\n        state.sCount[ddLine] = oldSCount;\n        state.tight = oldTight;\n        state.parentType = oldParentType;\n        state.blkIndent = oldIndent;\n        state.ddIndent = oldDDIndent;\n        token = state.push('dd_close', 'dd', -1);\n        itemLines[1] = nextLine = state.line;\n        if (nextLine >= endLine) {\n          break OUTER;\n        }\n        if (state.sCount[nextLine] < state.blkIndent) {\n          break OUTER;\n        }\n        contentStart = skipMarker(state, nextLine);\n        if (contentStart < 0) {\n          break;\n        }\n        ddLine = nextLine;\n\n        // go to the next loop iteration:\n        // insert DD tag and repeat checking\n      }\n      if (nextLine >= endLine) {\n        break;\n      }\n      dtLine = nextLine;\n      if (state.isEmpty(dtLine)) {\n        break;\n      }\n      if (state.sCount[dtLine] < state.blkIndent) {\n        break;\n      }\n      ddLine = dtLine + 1;\n      if (ddLine >= endLine) {\n        break;\n      }\n      if (state.isEmpty(ddLine)) {\n        ddLine++;\n      }\n      if (ddLine >= endLine) {\n        break;\n      }\n      if (state.sCount[ddLine] < state.blkIndent) {\n        break;\n      }\n      contentStart = skipMarker(state, ddLine);\n      if (contentStart < 0) {\n        break;\n      }\n\n      // go to the next loop iteration:\n      // insert DT and DD tags and repeat checking\n    }\n\n    // Finilize list\n    token = state.push('dl_close', 'dl', -1);\n    listLines[1] = nextLine;\n    state.line = nextLine;\n\n    // mark paragraphs tight if needed\n    if (tight) {\n      markTightParagraphs(state, listTokIdx);\n    }\n    return true;\n  }\n  md.block.ruler.before('paragraph', 'deflist', deflist, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  });\n};","map":null,"metadata":{},"sourceType":"script"}