{"ast":null,"code":"// GFM table, non-standard\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.map.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.regexp.exec.js\");\nrequire(\"core-js/modules/es.regexp.test.js\");\nrequire(\"core-js/modules/es.string.replace.js\");\nrequire(\"core-js/modules/es.string.trim.js\");\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n    max = state.eMarks[line];\n  return state.src.substr(pos, max - pos);\n}\nfunction escapedSplit(str) {\n  var result = [],\n    pos = 0,\n    max = str.length,\n    ch,\n    escapes = 0,\n    lastPos = 0,\n    backTicked = false,\n    lastBackTick = 0;\n  ch = str.charCodeAt(pos);\n  while (pos < max) {\n    if (ch === 0x60 /* ` */ && escapes % 2 === 0) {\n      backTicked = !backTicked;\n      lastBackTick = pos;\n    } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {\n      result.push(str.substring(lastPos, pos));\n      lastPos = pos + 1;\n    } else if (ch === 0x5c /* \\ */) {\n      escapes++;\n    } else {\n      escapes = 0;\n    }\n    pos++;\n\n    // If there was an un-closed backtick, go back to just after\n    // the last backtick, but as if it was a normal character\n    if (pos === max && backTicked) {\n      backTicked = false;\n      pos = lastBackTick + 1;\n    }\n    ch = str.charCodeAt(pos);\n  }\n  result.push(str.substring(lastPos));\n  return result;\n}\nmodule.exports = function table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;\n\n  // should have at least three lines\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n  nextLine = startLine + 1;\n  if (state.sCount[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  // first character of the second line should be '|' or '-'\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n  ch = state.src.charCodeAt(pos);\n  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {\n    return false;\n  }\n  lineText = getLine(state, startLine + 1);\n  if (!/^[-:| ]+$/.test(lineText)) {\n    return false;\n  }\n  columns = lineText.split('|');\n  aligns = [];\n  for (i = 0; i < columns.length; i++) {\n    t = columns[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n    if (!/^:?-+:?$/.test(t)) {\n      return false;\n    }\n    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A /* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) {\n    return false;\n  }\n  columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\n  // header row will define an amount of columns in the entire table,\n  // and align row shouldn't be smaller than that (the rest of the rows can)\n  columnCount = columns.length;\n  if (columnCount > aligns.length) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  token = state.push('table_open', 'table', 1);\n  token.map = tableLines = [startLine, 0];\n  token = state.push('thead_open', 'thead', 1);\n  token.map = [startLine, startLine + 1];\n  token = state.push('tr_open', 'tr', 1);\n  token.map = [startLine, startLine + 1];\n  for (i = 0; i < columns.length; i++) {\n    token = state.push('th_open', 'th', 1);\n    token.map = [startLine, startLine + 1];\n    if (aligns[i]) {\n      token.attrs = [['style', 'text-align:' + aligns[i]]];\n    }\n    token = state.push('inline', '', 0);\n    token.content = columns[i].trim();\n    token.map = [startLine, startLine + 1];\n    token.children = [];\n    token = state.push('th_close', 'th', -1);\n  }\n  token = state.push('tr_close', 'tr', -1);\n  token = state.push('thead_close', 'thead', -1);\n  token = state.push('tbody_open', 'tbody', 1);\n  token.map = tbodyLines = [startLine + 2, 0];\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n    lineText = getLine(state, nextLine);\n    if (lineText.indexOf('|') === -1) {\n      break;\n    }\n\n    // keep spaces at beginning of line to indicate an empty first cell, but\n    // strip trailing whitespace\n    columns = escapedSplit(lineText.replace(/^\\||\\|\\s*$/g, ''));\n    token = state.push('tr_open', 'tr', 1);\n    for (i = 0; i < columnCount; i++) {\n      token = state.push('td_open', 'td', 1);\n      if (aligns[i]) {\n        token.attrs = [['style', 'text-align:' + aligns[i]]];\n      }\n      token = state.push('inline', '', 0);\n      token.content = columns[i] ? columns[i].trim() : '';\n      token.children = [];\n      token = state.push('td_close', 'td', -1);\n    }\n    token = state.push('tr_close', 'tr', -1);\n  }\n  token = state.push('tbody_close', 'tbody', -1);\n  token = state.push('table_close', 'table', -1);\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}