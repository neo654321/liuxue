{"ast":null,"code":"// fences (``` lang, ~~~ lang)\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.map.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.slice.js\");\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker,\n    len,\n    params,\n    nextLine,\n    mem,\n    token,\n    markup,\n    haveEndMarker = false,\n    pos = state.bMarks[startLine] + state.tShift[startLine],\n    max = state.eMarks[startLine];\n  if (pos + 3 > max) {\n    return false;\n  }\n  marker = state.src.charCodeAt(pos);\n  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n  len = pos - mem;\n  if (len < 3) {\n    return false;\n  }\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n  if (params.indexOf('`') >= 0) {\n    return false;\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) {\n    return true;\n  }\n\n  // search end of block\n  nextLine = startLine;\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) {\n      continue;\n    }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n    if (pos < max) {\n      continue;\n    }\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  token = state.push('fence', 'code', 0);\n  token.info = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup = markup;\n  token.map = [startLine, state.line];\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}