{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.slice.js\");\n/* eslint no-constant-condition:0 */\nvar functions = require(\"./functions\");\nvar environments = require(\"./environments\");\nvar Lexer = require(\"./Lexer\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The earlier functions return ParseNodes.\n * The later functions (which are called deeper in the parse) sometimes return\n * ParseFuncOrArgument, which contain a ParseNode as well as some data about\n * whether the parsed object is a function which is missing some arguments, or a\n * standalone object which can be used as an argument to another function.\n */\n\n/**\n * Main Parser class\n */\nfunction Parser(input, settings) {\n  // Make a new lexer\n  this.lexer = new Lexer(input);\n  // Store the settings for use in parsing\n  this.settings = settings;\n}\nvar ParseNode = parseData.ParseNode;\n\n/**\n * An initial function (without its arguments), or an argument to a function.\n * The `result` argument should be a ParseNode.\n */\nfunction ParseFuncOrArgument(result, isFunction) {\n  this.result = result;\n  // Is this a function (i.e. is it something defined in functions.js)?\n  this.isFunction = isFunction;\n}\n\n/**\n * Checks a result to make sure it has the right type, and throws an\n * appropriate error otherwise.\n *\n * @param {boolean=} consume whether to consume the expected token,\n *                           defaults to true\n */\nParser.prototype.expect = function (text, consume) {\n  if (this.nextToken.text !== text) {\n    throw new ParseError(\"Expected '\" + text + \"', got '\" + this.nextToken.text + \"'\", this.lexer, this.nextToken.position);\n  }\n  if (consume !== false) {\n    this.consume();\n  }\n};\n\n/**\n * Considers the current look ahead token as consumed,\n * and fetches the one after that as the new look ahead.\n */\nParser.prototype.consume = function () {\n  this.pos = this.nextToken.position;\n  this.nextToken = this.lexer.lex(this.pos, this.mode);\n};\n\n/**\n * Main parsing function, which parses an entire input.\n *\n * @return {?Array.<ParseNode>}\n */\nParser.prototype.parse = function () {\n  // Try to parse the input\n  this.mode = \"math\";\n  this.pos = 0;\n  this.nextToken = this.lexer.lex(this.pos, this.mode);\n  var parse = this.parseInput();\n  return parse;\n};\n\n/**\n * Parses an entire input tree.\n */\nParser.prototype.parseInput = function () {\n  // Parse an expression\n  var expression = this.parseExpression(false);\n  // If we succeeded, make sure there's an EOF at the end\n  this.expect(\"EOF\", false);\n  return expression;\n};\nvar endOfExpression = [\"}\", \"\\\\end\", \"\\\\right\", \"&\", \"\\\\\\\\\", \"\\\\cr\"];\n\n/**\n * Parses an \"expression\", which is a list of atoms.\n *\n * @param {boolean} breakOnInfix Should the parsing stop when we hit infix\n *                  nodes? This happens when functions have higher precendence\n *                  than infix nodes in implicit parses.\n *\n * @param {?string} breakOnToken The token that the expression should end with,\n *                  or `null` if something else should end the expression.\n *\n * @return {ParseNode}\n */\nParser.prototype.parseExpression = function (breakOnInfix, breakOnToken) {\n  var body = [];\n  // Keep adding atoms to the body until we can't parse any more atoms (either\n  // we reached the end, a }, or a \\right)\n  while (true) {\n    var lex = this.nextToken;\n    var pos = this.pos;\n    if (endOfExpression.indexOf(lex.text) !== -1) {\n      break;\n    }\n    if (breakOnToken && lex.text === breakOnToken) {\n      break;\n    }\n    var atom = this.parseAtom();\n    if (!atom) {\n      if (!this.settings.throwOnError && lex.text[0] === \"\\\\\") {\n        var errorNode = this.handleUnsupportedCmd();\n        body.push(errorNode);\n        pos = lex.position;\n        continue;\n      }\n      break;\n    }\n    if (breakOnInfix && atom.type === \"infix\") {\n      // rewind so we can parse the infix atom again\n      this.pos = pos;\n      this.nextToken = lex;\n      break;\n    }\n    body.push(atom);\n  }\n  return this.handleInfixNodes(body);\n};\n\n/**\n * Rewrites infix operators such as \\over with corresponding commands such\n * as \\frac.\n *\n * There can only be one infix operator per group.  If there's more than one\n * then the expression is ambiguous.  This can be resolved by adding {}.\n *\n * @returns {Array}\n */\nParser.prototype.handleInfixNodes = function (body) {\n  var overIndex = -1;\n  var funcName;\n  for (var i = 0; i < body.length; i++) {\n    var node = body[i];\n    if (node.type === \"infix\") {\n      if (overIndex !== -1) {\n        throw new ParseError(\"only one infix operator per group\", this.lexer, -1);\n      }\n      overIndex = i;\n      funcName = node.value.replaceWith;\n    }\n  }\n  if (overIndex !== -1) {\n    var numerNode;\n    var denomNode;\n    var numerBody = body.slice(0, overIndex);\n    var denomBody = body.slice(overIndex + 1);\n    if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n      numerNode = numerBody[0];\n    } else {\n      numerNode = new ParseNode(\"ordgroup\", numerBody, this.mode);\n    }\n    if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n      denomNode = denomBody[0];\n    } else {\n      denomNode = new ParseNode(\"ordgroup\", denomBody, this.mode);\n    }\n    var value = this.callFunction(funcName, [numerNode, denomNode], null);\n    return [new ParseNode(value.type, value, this.mode)];\n  } else {\n    return body;\n  }\n};\n\n// The greediness of a superscript or subscript\nvar SUPSUB_GREEDINESS = 1;\n\n/**\n * Handle a subscript or superscript with nice errors.\n */\nParser.prototype.handleSupSubscript = function (name) {\n  var symbol = this.nextToken.text;\n  var symPos = this.pos;\n  this.consume();\n  var group = this.parseGroup();\n  if (!group) {\n    if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n      return this.handleUnsupportedCmd();\n    } else {\n      throw new ParseError(\"Expected group after '\" + symbol + \"'\", this.lexer, symPos + 1);\n    }\n  } else if (group.isFunction) {\n    // ^ and _ have a greediness, so handle interactions with functions'\n    // greediness\n    var funcGreediness = functions[group.result].greediness;\n    if (funcGreediness > SUPSUB_GREEDINESS) {\n      return this.parseFunction(group);\n    } else {\n      throw new ParseError(\"Got function '\" + group.result + \"' with no arguments \" + \"as \" + name, this.lexer, symPos + 1);\n    }\n  } else {\n    return group.result;\n  }\n};\n\n/**\n * Converts the textual input of an unsupported command into a text node\n * contained within a color node whose color is determined by errorColor\n */\nParser.prototype.handleUnsupportedCmd = function () {\n  var text = this.nextToken.text;\n  var textordArray = [];\n  for (var i = 0; i < text.length; i++) {\n    textordArray.push(new ParseNode(\"textord\", text[i], \"text\"));\n  }\n  var textNode = new ParseNode(\"text\", {\n    body: textordArray,\n    type: \"text\"\n  }, this.mode);\n  var colorNode = new ParseNode(\"color\", {\n    color: this.settings.errorColor,\n    value: [textNode],\n    type: \"color\"\n  }, this.mode);\n  this.consume();\n  return colorNode;\n};\n\n/**\n * Parses a group with optional super/subscripts.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseAtom = function () {\n  // The body of an atom is an implicit group, so that things like\n  // \\left(x\\right)^2 work correctly.\n  var base = this.parseImplicitGroup();\n\n  // In text mode, we don't have superscripts or subscripts\n  if (this.mode === \"text\") {\n    return base;\n  }\n\n  // Note that base may be empty (i.e. null) at this point.\n\n  var superscript;\n  var subscript;\n  while (true) {\n    // Lex the first token\n    var lex = this.nextToken;\n    if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n      // We got a limit control\n      if (!base || base.type !== \"op\") {\n        throw new ParseError(\"Limit controls must follow a math operator\", this.lexer, this.pos);\n      } else {\n        var limits = lex.text === \"\\\\limits\";\n        base.value.limits = limits;\n        base.value.alwaysHandleSupSub = true;\n      }\n      this.consume();\n    } else if (lex.text === \"^\") {\n      // We got a superscript start\n      if (superscript) {\n        throw new ParseError(\"Double superscript\", this.lexer, this.pos);\n      }\n      superscript = this.handleSupSubscript(\"superscript\");\n    } else if (lex.text === \"_\") {\n      // We got a subscript start\n      if (subscript) {\n        throw new ParseError(\"Double subscript\", this.lexer, this.pos);\n      }\n      subscript = this.handleSupSubscript(\"subscript\");\n    } else if (lex.text === \"'\") {\n      // We got a prime\n      var prime = new ParseNode(\"textord\", \"\\\\prime\", this.mode);\n\n      // Many primes can be grouped together, so we handle this here\n      var primes = [prime];\n      this.consume();\n      // Keep lexing tokens until we get something that's not a prime\n      while (this.nextToken.text === \"'\") {\n        // For each one, add another prime to the list\n        primes.push(prime);\n        this.consume();\n      }\n      // Put them into an ordgroup as the superscript\n      superscript = new ParseNode(\"ordgroup\", primes, this.mode);\n    } else {\n      // If it wasn't ^, _, or ', stop parsing super/subscripts\n      break;\n    }\n  }\n  if (superscript || subscript) {\n    // If we got either a superscript or subscript, create a supsub\n    return new ParseNode(\"supsub\", {\n      base: base,\n      sup: superscript,\n      sub: subscript\n    }, this.mode);\n  } else {\n    // Otherwise return the original body\n    return base;\n  }\n};\n\n// A list of the size-changing functions, for use in parseImplicitGroup\nvar sizeFuncs = [\"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"];\n\n// A list of the style-changing functions, for use in parseImplicitGroup\nvar styleFuncs = [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"];\n\n/**\n * Parses an implicit group, which is a group that starts at the end of a\n * specified, and ends right before a higher explicit group ends, or at EOL. It\n * is used for functions that appear to affect the current style, like \\Large or\n * \\textrm, where instead of keeping a style we just pretend that there is an\n * implicit grouping after it until the end of the group. E.g.\n *   small text {\\Large large text} small text again\n * It is also used for \\left and \\right to get the correct grouping.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseImplicitGroup = function () {\n  var start = this.parseSymbol();\n  if (start == null) {\n    // If we didn't get anything we handle, fall back to parseFunction\n    return this.parseFunction();\n  }\n  var func = start.result;\n  var body;\n  if (func === \"\\\\left\") {\n    // If we see a left:\n    // Parse the entire left function (including the delimiter)\n    var left = this.parseFunction(start);\n    // Parse out the implicit body\n    body = this.parseExpression(false);\n    // Check the next token\n    this.expect(\"\\\\right\", false);\n    var right = this.parseFunction();\n    return new ParseNode(\"leftright\", {\n      body: body,\n      left: left.value.value,\n      right: right.value.value\n    }, this.mode);\n  } else if (func === \"\\\\begin\") {\n    // begin...end is similar to left...right\n    var begin = this.parseFunction(start);\n    var envName = begin.value.name;\n    if (!environments.hasOwnProperty(envName)) {\n      throw new ParseError(\"No such environment: \" + envName, this.lexer, begin.value.namepos);\n    }\n    // Build the environment object. Arguments and other information will\n    // be made available to the begin and end methods using properties.\n    var env = environments[envName];\n    var args = this.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n    var context = {\n      mode: this.mode,\n      envName: envName,\n      parser: this,\n      lexer: this.lexer,\n      positions: args.pop()\n    };\n    var result = env.handler(context, args);\n    this.expect(\"\\\\end\", false);\n    var end = this.parseFunction();\n    if (end.value.name !== envName) {\n      throw new ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched \" + \"by \\\\end{\" + end.value.name + \"}\", this.lexer /* , end.value.namepos */);\n      // TODO: Add position to the above line and adjust test case,\n      // requires #385 to get merged first\n    }\n    result.position = end.position;\n    return result;\n  } else if (utils.contains(sizeFuncs, func)) {\n    // If we see a sizing function, parse out the implict body\n    body = this.parseExpression(false);\n    return new ParseNode(\"sizing\", {\n      // Figure out what size to use based on the list of functions above\n      size: \"size\" + (utils.indexOf(sizeFuncs, func) + 1),\n      value: body\n    }, this.mode);\n  } else if (utils.contains(styleFuncs, func)) {\n    // If we see a styling function, parse out the implict body\n    body = this.parseExpression(true);\n    return new ParseNode(\"styling\", {\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style: func.slice(1, func.length - 5),\n      value: body\n    }, this.mode);\n  } else {\n    // Defer to parseFunction if it's not a function we handle\n    return this.parseFunction(start);\n  }\n};\n\n/**\n * Parses an entire function, including its base and all of its arguments.\n * The base might either have been parsed already, in which case\n * it is provided as an argument, or it's the next group in the input.\n *\n * @param {ParseFuncOrArgument=} baseGroup optional as described above\n * @return {?ParseNode}\n */\nParser.prototype.parseFunction = function (baseGroup) {\n  if (!baseGroup) {\n    baseGroup = this.parseGroup();\n  }\n  if (baseGroup) {\n    if (baseGroup.isFunction) {\n      var func = baseGroup.result;\n      var funcData = functions[func];\n      if (this.mode === \"text\" && !funcData.allowedInText) {\n        throw new ParseError(\"Can't use function '\" + func + \"' in text mode\", this.lexer, baseGroup.position);\n      }\n      var args = this.parseArguments(func, funcData);\n      var result = this.callFunction(func, args, args.pop());\n      return new ParseNode(result.type, result, this.mode);\n    } else {\n      return baseGroup.result;\n    }\n  } else {\n    return null;\n  }\n};\n\n/**\n * Call a function handler with a suitable context and arguments.\n */\nParser.prototype.callFunction = function (name, args, positions) {\n  var context = {\n    funcName: name,\n    parser: this,\n    lexer: this.lexer,\n    positions: positions\n  };\n  return functions[name].handler(context, args);\n};\n\n/**\n * Parses the arguments of a function or environment\n *\n * @param {string} func  \"\\name\" or \"\\begin{name}\"\n * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData\n * @return the array of arguments, with the list of positions as last element\n */\nParser.prototype.parseArguments = function (func, funcData) {\n  var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n  if (totalArgs === 0) {\n    return [[this.pos]];\n  }\n  var baseGreediness = funcData.greediness;\n  var positions = [this.pos];\n  var args = [];\n  for (var i = 0; i < totalArgs; i++) {\n    var argType = funcData.argTypes && funcData.argTypes[i];\n    var arg;\n    if (i < funcData.numOptionalArgs) {\n      if (argType) {\n        arg = this.parseSpecialGroup(argType, true);\n      } else {\n        arg = this.parseOptionalGroup();\n      }\n      if (!arg) {\n        args.push(null);\n        positions.push(this.pos);\n        continue;\n      }\n    } else {\n      if (argType) {\n        arg = this.parseSpecialGroup(argType);\n      } else {\n        arg = this.parseGroup();\n      }\n      if (!arg) {\n        if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n          arg = new ParseFuncOrArgument(this.handleUnsupportedCmd(this.nextToken.text), false);\n        } else {\n          throw new ParseError(\"Expected group after '\" + func + \"'\", this.lexer, this.pos);\n        }\n      }\n    }\n    var argNode;\n    if (arg.isFunction) {\n      var argGreediness = functions[arg.result].greediness;\n      if (argGreediness > baseGreediness) {\n        argNode = this.parseFunction(arg);\n      } else {\n        throw new ParseError(\"Got function '\" + arg.result + \"' as \" + \"argument to '\" + func + \"'\", this.lexer, this.pos - 1);\n      }\n    } else {\n      argNode = arg.result;\n    }\n    args.push(argNode);\n    positions.push(this.pos);\n  }\n  args.push(positions);\n  return args;\n};\n\n/**\n * Parses a group when the mode is changing. Takes a position, a new mode, and\n * an outer mode that is used to parse the outside.\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseSpecialGroup = function (innerMode, optional) {\n  var outerMode = this.mode;\n  // Handle `original` argTypes\n  if (innerMode === \"original\") {\n    innerMode = outerMode;\n  }\n  if (innerMode === \"color\" || innerMode === \"size\") {\n    // color and size modes are special because they should have braces and\n    // should only lex a single symbol inside\n    var openBrace = this.nextToken;\n    if (optional && openBrace.text !== \"[\") {\n      // optional arguments should return null if they don't exist\n      return null;\n    }\n    // The call to expect will lex the token after the '{' in inner mode\n    this.mode = innerMode;\n    this.expect(optional ? \"[\" : \"{\");\n    var inner = this.nextToken;\n    this.mode = outerMode;\n    var data;\n    if (innerMode === \"color\") {\n      data = inner.text;\n    } else {\n      data = inner.data;\n    }\n    this.consume(); // consume the token stored in inner\n    this.expect(optional ? \"]\" : \"}\");\n    return new ParseFuncOrArgument(new ParseNode(innerMode, data, outerMode), false);\n  } else if (innerMode === \"text\") {\n    // text mode is special because it should ignore the whitespace before\n    // it\n    var whitespace = this.lexer.lex(this.pos, \"whitespace\");\n    this.pos = whitespace.position;\n  }\n\n  // By the time we get here, innerMode is one of \"text\" or \"math\".\n  // We switch the mode of the parser, recurse, then restore the old mode.\n  this.mode = innerMode;\n  this.nextToken = this.lexer.lex(this.pos, innerMode);\n  var res;\n  if (optional) {\n    res = this.parseOptionalGroup();\n  } else {\n    res = this.parseGroup();\n  }\n  this.mode = outerMode;\n  this.nextToken = this.lexer.lex(this.pos, outerMode);\n  return res;\n};\n\n/**\n * Parses a group, which is either a single nucleus (like \"x\") or an expression\n * in braces (like \"{x+y}\")\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseGroup = function () {\n  // Try to parse an open brace\n  if (this.nextToken.text === \"{\") {\n    // If we get a brace, parse an expression\n    this.consume();\n    var expression = this.parseExpression(false);\n    // Make sure we get a close brace\n    this.expect(\"}\");\n    return new ParseFuncOrArgument(new ParseNode(\"ordgroup\", expression, this.mode), false);\n  } else {\n    // Otherwise, just return a nucleus\n    return this.parseSymbol();\n  }\n};\n\n/**\n * Parses a group, which is an expression in brackets (like \"[x+y]\")\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseOptionalGroup = function () {\n  // Try to parse an open bracket\n  if (this.nextToken.text === \"[\") {\n    // If we get a brace, parse an expression\n    this.consume();\n    var expression = this.parseExpression(false, \"]\");\n    // Make sure we get a close bracket\n    this.expect(\"]\");\n    return new ParseFuncOrArgument(new ParseNode(\"ordgroup\", expression, this.mode), false);\n  } else {\n    // Otherwise, return null,\n    return null;\n  }\n};\n\n/**\n * Parse a single symbol out of the string. Here, we handle both the functions\n * we have defined, as well as the single character symbols\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseSymbol = function () {\n  var nucleus = this.nextToken;\n  if (functions[nucleus.text]) {\n    this.consume();\n    // If there exists a function with this name, we return the function and\n    // say that it is a function.\n    return new ParseFuncOrArgument(nucleus.text, true);\n  } else if (symbols[this.mode][nucleus.text]) {\n    this.consume();\n    // Otherwise if this is a no-argument function, find the type it\n    // corresponds to in the symbols map\n    return new ParseFuncOrArgument(new ParseNode(symbols[this.mode][nucleus.text].group, nucleus.text, this.mode), false);\n  } else {\n    return null;\n  }\n};\nParser.prototype.ParseNode = ParseNode;\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}