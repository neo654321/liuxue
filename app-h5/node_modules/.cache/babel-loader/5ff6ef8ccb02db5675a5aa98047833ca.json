{"ast":null,"code":"require(\"core-js/modules/es.regexp.constructor.js\");\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\nrequire(\"core-js/modules/es.regexp.exec.js\");\nrequire(\"core-js/modules/es.regexp.sticky.js\");\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\nvar matchAt = require(\"match-at\");\nvar ParseError = require(\"./ParseError\");\n\n// The main lexer class\nfunction Lexer(input) {\n  this._input = input;\n}\n\n// The resulting token returned from `lex`.\nfunction Token(text, data, position) {\n  this.text = text;\n  this.data = data;\n  this.position = position;\n}\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - matches symbol combinations which result in a single output character\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more letters\n * - matches a backslash followed by any BMP character, including newline\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nvar tokenRegex = new RegExp(\"([ \\r\\n\\t]+)|(\" +\n// whitespace\n\"---?\" +\n// special combinations\n\"|[!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" +\n// single codepoint\n\"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" +\n// surrogate pair\n\"|\\\\\\\\(?:[a-zA-Z]+|[^\\uD800-\\uDFFF])\" +\n// function name\n\")\");\nvar whitespaceRegex = /\\s*/;\n\n/**\n * This function lexes a single normal token. It takes a position and\n * whether it should completely ignore whitespace or not.\n */\nLexer.prototype._innerLex = function (pos, ignoreWhitespace) {\n  var input = this._input;\n  if (pos === input.length) {\n    return new Token(\"EOF\", null, pos);\n  }\n  var match = matchAt(tokenRegex, input, pos);\n  if (match === null) {\n    throw new ParseError(\"Unexpected character: '\" + input[pos] + \"'\", this, pos);\n  } else if (match[2]) {\n    // matched non-whitespace\n    return new Token(match[2], null, pos + match[2].length);\n  } else if (ignoreWhitespace) {\n    return this._innerLex(pos + match[1].length, true);\n  } else {\n    // concatenate whitespace to a single space\n    return new Token(\" \", null, pos + match[1].length);\n  }\n};\n\n// A regex to match a CSS color (like #ffffff or BlueViolet)\nvar cssColor = /#[a-z0-9]+|[a-z]+/i;\n\n/**\n * This function lexes a CSS color.\n */\nLexer.prototype._innerLexColor = function (pos) {\n  var input = this._input;\n\n  // Ignore whitespace\n  var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n  pos += whitespace.length;\n  var match;\n  if (match = matchAt(cssColor, input, pos)) {\n    // If we look like a color, return a color\n    return new Token(match[0], null, pos + match[0].length);\n  } else {\n    throw new ParseError(\"Invalid color\", this, pos);\n  }\n};\n\n// A regex to match a dimension. Dimensions look like\n// \"1.2em\" or \".4pt\" or \"1 ex\"\nvar sizeRegex = /(-?)\\s*(\\d+(?:\\.\\d*)?|\\.\\d+)\\s*([a-z]{2})/;\n\n/**\n * This function lexes a dimension.\n */\nLexer.prototype._innerLexSize = function (pos) {\n  var input = this._input;\n\n  // Ignore whitespace\n  var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n  pos += whitespace.length;\n  var match;\n  if (match = matchAt(sizeRegex, input, pos)) {\n    var unit = match[3];\n    // We only currently handle \"em\" and \"ex\" units\n    if (unit !== \"em\" && unit !== \"ex\") {\n      throw new ParseError(\"Invalid unit: '\" + unit + \"'\", this, pos);\n    }\n    return new Token(match[0], {\n      number: +(match[1] + match[2]),\n      unit: unit\n    }, pos + match[0].length);\n  }\n  throw new ParseError(\"Invalid size\", this, pos);\n};\n\n/**\n * This function lexes a string of whitespace.\n */\nLexer.prototype._innerLexWhitespace = function (pos) {\n  var input = this._input;\n  var whitespace = matchAt(whitespaceRegex, input, pos)[0];\n  pos += whitespace.length;\n  return new Token(whitespace[0], null, pos);\n};\n\n/**\n * This function lexes a single token starting at `pos` and of the given mode.\n * Based on the mode, we defer to one of the `_innerLex` functions.\n */\nLexer.prototype.lex = function (pos, mode) {\n  if (mode === \"math\") {\n    return this._innerLex(pos, true);\n  } else if (mode === \"text\") {\n    return this._innerLex(pos, false);\n  } else if (mode === \"color\") {\n    return this._innerLexColor(pos);\n  } else if (mode === \"size\") {\n    return this._innerLexSize(pos);\n  } else if (mode === \"whitespace\") {\n    return this._innerLexWhitespace(pos);\n  }\n};\nmodule.exports = Lexer;","map":null,"metadata":{},"sourceType":"script"}