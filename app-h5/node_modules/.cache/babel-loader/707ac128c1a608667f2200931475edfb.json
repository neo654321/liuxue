{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\nrequire(\"core-js/modules/es.json.stringify.js\");\n/* eslint no-console:0 */\n/**\n * This file does the main work of building a domTree structure from a parse\n * tree. The entry point is the `buildHTML` function, which takes a parse tree.\n * Then, the buildExpression, buildGroup, and various groupTypes functions are\n * called, to produce a final HTML tree.\n */\n\nvar ParseError = require(\"./ParseError\");\nvar Style = require(\"./Style\");\nvar buildCommon = require(\"./buildCommon\");\nvar delimiter = require(\"./delimiter\");\nvar domTree = require(\"./domTree\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar utils = require(\"./utils\");\nvar makeSpan = buildCommon.makeSpan;\n\n/**\n * Take a list of nodes, build them in order, and return a list of the built\n * nodes. This function handles the `prev` node correctly, and passes the\n * previous element from the list as the prev of the next element.\n */\nvar buildExpression = function buildExpression(expression, options, prev) {\n  var groups = [];\n  for (var i = 0; i < expression.length; i++) {\n    var group = expression[i];\n    groups.push(buildGroup(group, options, prev));\n    prev = group;\n  }\n  return groups;\n};\n\n// List of types used by getTypeOfGroup,\n// see https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types\nvar groupToType = {\n  mathord: \"mord\",\n  textord: \"mord\",\n  bin: \"mbin\",\n  rel: \"mrel\",\n  text: \"mord\",\n  open: \"mopen\",\n  close: \"mclose\",\n  inner: \"minner\",\n  genfrac: \"mord\",\n  array: \"mord\",\n  spacing: \"mord\",\n  punct: \"mpunct\",\n  ordgroup: \"mord\",\n  op: \"mop\",\n  katex: \"mord\",\n  overline: \"mord\",\n  underline: \"mord\",\n  rule: \"mord\",\n  leftright: \"minner\",\n  sqrt: \"mord\",\n  accent: \"mord\"\n};\n\n/**\n * Gets the final math type of an expression, given its group type. This type is\n * used to determine spacing between elements, and affects bin elements by\n * causing them to change depending on what types are around them. This type\n * must be attached to the outermost node of an element as a CSS class so that\n * spacing with its surrounding elements works correctly.\n *\n * Some elements can be mapped one-to-one from group type to math type, and\n * those are listed in the `groupToType` table.\n *\n * Others (usually elements that wrap around other elements) often have\n * recursive definitions, and thus call `getTypeOfGroup` on their inner\n * elements.\n */\nvar getTypeOfGroup = function getTypeOfGroup(group) {\n  if (group == null) {\n    // Like when typesetting $^3$\n    return groupToType.mathord;\n  } else if (group.type === \"supsub\") {\n    return getTypeOfGroup(group.value.base);\n  } else if (group.type === \"llap\" || group.type === \"rlap\") {\n    return getTypeOfGroup(group.value);\n  } else if (group.type === \"color\") {\n    return getTypeOfGroup(group.value.value);\n  } else if (group.type === \"sizing\") {\n    return getTypeOfGroup(group.value.value);\n  } else if (group.type === \"styling\") {\n    return getTypeOfGroup(group.value.value);\n  } else if (group.type === \"delimsizing\") {\n    return groupToType[group.value.delimType];\n  } else {\n    return groupToType[group.type];\n  }\n};\n\n/**\n * Sometimes, groups perform special rules when they have superscripts or\n * subscripts attached to them. This function lets the `supsub` group know that\n * its inner element should handle the superscripts and subscripts instead of\n * handling them itself.\n */\nvar shouldHandleSupSub = function shouldHandleSupSub(group, options) {\n  if (!group) {\n    return false;\n  } else if (group.type === \"op\") {\n    // Operators handle supsubs differently when they have limits\n    // (e.g. `\\displaystyle\\sum_2^3`)\n    return group.value.limits && (options.style.size === Style.DISPLAY.size || group.value.alwaysHandleSupSub);\n  } else if (group.type === \"accent\") {\n    return isCharacterBox(group.value.base);\n  } else {\n    return null;\n  }\n};\n\n/**\n * Sometimes we want to pull out the innermost element of a group. In most\n * cases, this will just be the group itself, but when ordgroups and colors have\n * a single element, we want to pull that out.\n */\nvar getBaseElem = function getBaseElem(group) {\n  if (!group) {\n    return false;\n  } else if (group.type === \"ordgroup\") {\n    if (group.value.length === 1) {\n      return getBaseElem(group.value[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"color\") {\n    if (group.value.value.length === 1) {\n      return getBaseElem(group.value.value[0]);\n    } else {\n      return group;\n    }\n  } else {\n    return group;\n  }\n};\n\n/**\n * TeXbook algorithms often reference \"character boxes\", which are simply groups\n * with a single character in them. To decide if something is a character box,\n * we find its innermost group, and see if it is a single character.\n */\nvar isCharacterBox = function isCharacterBox(group) {\n  var baseElem = getBaseElem(group);\n\n  // These are all they types of groups which hold single characters\n  return baseElem.type === \"mathord\" || baseElem.type === \"textord\" || baseElem.type === \"bin\" || baseElem.type === \"rel\" || baseElem.type === \"inner\" || baseElem.type === \"open\" || baseElem.type === \"close\" || baseElem.type === \"punct\";\n};\nvar makeNullDelimiter = function makeNullDelimiter(options) {\n  return makeSpan([\"sizing\", \"reset-\" + options.size, \"size5\", options.style.reset(), Style.TEXT.cls(), \"nulldelimiter\"]);\n};\n\n/**\n * This is a map of group types to the function used to handle that type.\n * Simpler types come at the beginning, while complicated types come afterwards.\n */\nvar groupTypes = {};\ngroupTypes.mathord = function (group, options, prev) {\n  return buildCommon.makeOrd(group, options, \"mathord\");\n};\ngroupTypes.textord = function (group, options, prev) {\n  return buildCommon.makeOrd(group, options, \"textord\");\n};\ngroupTypes.bin = function (group, options, prev) {\n  var className = \"mbin\";\n  // Pull out the most recent element. Do some special handling to find\n  // things at the end of a \\color group. Note that we don't use the same\n  // logic for ordgroups (which count as ords).\n  var prevAtom = prev;\n  while (prevAtom && prevAtom.type === \"color\") {\n    var atoms = prevAtom.value.value;\n    prevAtom = atoms[atoms.length - 1];\n  }\n  // See TeXbook pg. 442-446, Rules 5 and 6, and the text before Rule 19.\n  // Here, we determine whether the bin should turn into an ord. We\n  // currently only apply Rule 5.\n  if (!prev || utils.contains([\"mbin\", \"mopen\", \"mrel\", \"mop\", \"mpunct\"], getTypeOfGroup(prevAtom))) {\n    group.type = \"textord\";\n    className = \"mord\";\n  }\n  return buildCommon.mathsym(group.value, group.mode, options.getColor(), [className]);\n};\ngroupTypes.rel = function (group, options, prev) {\n  return buildCommon.mathsym(group.value, group.mode, options.getColor(), [\"mrel\"]);\n};\ngroupTypes.open = function (group, options, prev) {\n  return buildCommon.mathsym(group.value, group.mode, options.getColor(), [\"mopen\"]);\n};\ngroupTypes.close = function (group, options, prev) {\n  return buildCommon.mathsym(group.value, group.mode, options.getColor(), [\"mclose\"]);\n};\ngroupTypes.inner = function (group, options, prev) {\n  return buildCommon.mathsym(group.value, group.mode, options.getColor(), [\"minner\"]);\n};\ngroupTypes.punct = function (group, options, prev) {\n  return buildCommon.mathsym(group.value, group.mode, options.getColor(), [\"mpunct\"]);\n};\ngroupTypes.ordgroup = function (group, options, prev) {\n  return makeSpan([\"mord\", options.style.cls()], buildExpression(group.value, options.reset()));\n};\ngroupTypes.text = function (group, options, prev) {\n  return makeSpan([\"text\", \"mord\", options.style.cls()], buildExpression(group.value.body, options.reset()));\n};\ngroupTypes.color = function (group, options, prev) {\n  var elements = buildExpression(group.value.value, options.withColor(group.value.color), prev);\n\n  // \\color isn't supposed to affect the type of the elements it contains.\n  // To accomplish this, we wrap the results in a fragment, so the inner\n  // elements will be able to directly interact with their neighbors. For\n  // example, `\\color{red}{2 +} 3` has the same spacing as `2 + 3`\n  return new buildCommon.makeFragment(elements);\n};\ngroupTypes.supsub = function (group, options, prev) {\n  // Superscript and subscripts are handled in the TeXbook on page\n  // 445-446, rules 18(a-f).\n\n  // Here is where we defer to the inner group if it should handle\n  // superscripts and subscripts itself.\n  if (shouldHandleSupSub(group.value.base, options)) {\n    return groupTypes[group.value.base.type](group, options, prev);\n  }\n  var base = buildGroup(group.value.base, options.reset());\n  var supmid;\n  var submid;\n  var sup;\n  var sub;\n  if (group.value.sup) {\n    sup = buildGroup(group.value.sup, options.withStyle(options.style.sup()));\n    supmid = makeSpan([options.style.reset(), options.style.sup().cls()], [sup]);\n  }\n  if (group.value.sub) {\n    sub = buildGroup(group.value.sub, options.withStyle(options.style.sub()));\n    submid = makeSpan([options.style.reset(), options.style.sub().cls()], [sub]);\n  }\n\n  // Rule 18a\n  var supShift;\n  var subShift;\n  if (isCharacterBox(group.value.base)) {\n    supShift = 0;\n    subShift = 0;\n  } else {\n    supShift = base.height - fontMetrics.metrics.supDrop;\n    subShift = base.depth + fontMetrics.metrics.subDrop;\n  }\n\n  // Rule 18c\n  var minSupShift;\n  if (options.style === Style.DISPLAY) {\n    minSupShift = fontMetrics.metrics.sup1;\n  } else if (options.style.cramped) {\n    minSupShift = fontMetrics.metrics.sup3;\n  } else {\n    minSupShift = fontMetrics.metrics.sup2;\n  }\n\n  // scriptspace is a font-size-independent size, so scale it\n  // appropriately\n  var multiplier = Style.TEXT.sizeMultiplier * options.style.sizeMultiplier;\n  var scriptspace = 0.5 / fontMetrics.metrics.ptPerEm / multiplier + \"em\";\n  var supsub;\n  if (!group.value.sup) {\n    // Rule 18b\n    subShift = Math.max(subShift, fontMetrics.metrics.sub1, sub.height - 0.8 * fontMetrics.metrics.xHeight);\n    supsub = buildCommon.makeVList([{\n      type: \"elem\",\n      elem: submid\n    }], \"shift\", subShift, options);\n    supsub.children[0].style.marginRight = scriptspace;\n\n    // Subscripts shouldn't be shifted by the base's italic correction.\n    // Account for that by shifting the subscript back the appropriate\n    // amount. Note we only do this when the base is a single symbol.\n    if (base instanceof domTree.symbolNode) {\n      supsub.children[0].style.marginLeft = -base.italic + \"em\";\n    }\n  } else if (!group.value.sub) {\n    // Rule 18c, d\n    supShift = Math.max(supShift, minSupShift, sup.depth + 0.25 * fontMetrics.metrics.xHeight);\n    supsub = buildCommon.makeVList([{\n      type: \"elem\",\n      elem: supmid\n    }], \"shift\", -supShift, options);\n    supsub.children[0].style.marginRight = scriptspace;\n  } else {\n    supShift = Math.max(supShift, minSupShift, sup.depth + 0.25 * fontMetrics.metrics.xHeight);\n    subShift = Math.max(subShift, fontMetrics.metrics.sub2);\n    var ruleWidth = fontMetrics.metrics.defaultRuleThickness;\n\n    // Rule 18e\n    if (supShift - sup.depth - (sub.height - subShift) < 4 * ruleWidth) {\n      subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;\n      var psi = 0.8 * fontMetrics.metrics.xHeight - (supShift - sup.depth);\n      if (psi > 0) {\n        supShift += psi;\n        subShift -= psi;\n      }\n    }\n    supsub = buildCommon.makeVList([{\n      type: \"elem\",\n      elem: submid,\n      shift: subShift\n    }, {\n      type: \"elem\",\n      elem: supmid,\n      shift: -supShift\n    }], \"individualShift\", null, options);\n\n    // See comment above about subscripts not being shifted\n    if (base instanceof domTree.symbolNode) {\n      supsub.children[0].style.marginLeft = -base.italic + \"em\";\n    }\n    supsub.children[0].style.marginRight = scriptspace;\n    supsub.children[1].style.marginRight = scriptspace;\n  }\n  return makeSpan([getTypeOfGroup(group.value.base)], [base, supsub]);\n};\ngroupTypes.genfrac = function (group, options, prev) {\n  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).\n  // Figure out what style this fraction should be in based on the\n  // function used\n  var fstyle = options.style;\n  if (group.value.size === \"display\") {\n    fstyle = Style.DISPLAY;\n  } else if (group.value.size === \"text\") {\n    fstyle = Style.TEXT;\n  }\n  var nstyle = fstyle.fracNum();\n  var dstyle = fstyle.fracDen();\n  var numer = buildGroup(group.value.numer, options.withStyle(nstyle));\n  var numerreset = makeSpan([fstyle.reset(), nstyle.cls()], [numer]);\n  var denom = buildGroup(group.value.denom, options.withStyle(dstyle));\n  var denomreset = makeSpan([fstyle.reset(), dstyle.cls()], [denom]);\n  var ruleWidth;\n  if (group.value.hasBarLine) {\n    ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;\n  } else {\n    ruleWidth = 0;\n  }\n\n  // Rule 15b\n  var numShift;\n  var clearance;\n  var denomShift;\n  if (fstyle.size === Style.DISPLAY.size) {\n    numShift = fontMetrics.metrics.num1;\n    if (ruleWidth > 0) {\n      clearance = 3 * ruleWidth;\n    } else {\n      clearance = 7 * fontMetrics.metrics.defaultRuleThickness;\n    }\n    denomShift = fontMetrics.metrics.denom1;\n  } else {\n    if (ruleWidth > 0) {\n      numShift = fontMetrics.metrics.num2;\n      clearance = ruleWidth;\n    } else {\n      numShift = fontMetrics.metrics.num3;\n      clearance = 3 * fontMetrics.metrics.defaultRuleThickness;\n    }\n    denomShift = fontMetrics.metrics.denom2;\n  }\n  var frac;\n  if (ruleWidth === 0) {\n    // Rule 15c\n    var candiateClearance = numShift - numer.depth - (denom.height - denomShift);\n    if (candiateClearance < clearance) {\n      numShift += 0.5 * (clearance - candiateClearance);\n      denomShift += 0.5 * (clearance - candiateClearance);\n    }\n    frac = buildCommon.makeVList([{\n      type: \"elem\",\n      elem: denomreset,\n      shift: denomShift\n    }, {\n      type: \"elem\",\n      elem: numerreset,\n      shift: -numShift\n    }], \"individualShift\", null, options);\n  } else {\n    // Rule 15d\n    var axisHeight = fontMetrics.metrics.axisHeight;\n    if (numShift - numer.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {\n      numShift += clearance - (numShift - numer.depth - (axisHeight + 0.5 * ruleWidth));\n    }\n    if (axisHeight - 0.5 * ruleWidth - (denom.height - denomShift) < clearance) {\n      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denom.height - denomShift));\n    }\n    var mid = makeSpan([options.style.reset(), Style.TEXT.cls(), \"frac-line\"]);\n    // Manually set the height of the line because its height is\n    // created in CSS\n    mid.height = ruleWidth;\n    var midShift = -(axisHeight - 0.5 * ruleWidth);\n    frac = buildCommon.makeVList([{\n      type: \"elem\",\n      elem: denomreset,\n      shift: denomShift\n    }, {\n      type: \"elem\",\n      elem: mid,\n      shift: midShift\n    }, {\n      type: \"elem\",\n      elem: numerreset,\n      shift: -numShift\n    }], \"individualShift\", null, options);\n  }\n\n  // Since we manually change the style sometimes (with \\dfrac or \\tfrac),\n  // account for the possible size change here.\n  frac.height *= fstyle.sizeMultiplier / options.style.sizeMultiplier;\n  frac.depth *= fstyle.sizeMultiplier / options.style.sizeMultiplier;\n\n  // Rule 15e\n  var delimSize;\n  if (fstyle.size === Style.DISPLAY.size) {\n    delimSize = fontMetrics.metrics.delim1;\n  } else {\n    delimSize = fontMetrics.metrics.getDelim2(fstyle);\n  }\n  var leftDelim;\n  var rightDelim;\n  if (group.value.leftDelim == null) {\n    leftDelim = makeNullDelimiter(options);\n  } else {\n    leftDelim = delimiter.customSizedDelim(group.value.leftDelim, delimSize, true, options.withStyle(fstyle), group.mode);\n  }\n  if (group.value.rightDelim == null) {\n    rightDelim = makeNullDelimiter(options);\n  } else {\n    rightDelim = delimiter.customSizedDelim(group.value.rightDelim, delimSize, true, options.withStyle(fstyle), group.mode);\n  }\n  return makeSpan([\"mord\", options.style.reset(), fstyle.cls()], [leftDelim, makeSpan([\"mfrac\"], [frac]), rightDelim], options.getColor());\n};\ngroupTypes.array = function (group, options, prev) {\n  var r;\n  var c;\n  var nr = group.value.body.length;\n  var nc = 0;\n  var body = new Array(nr);\n\n  // Horizontal spacing\n  var pt = 1 / fontMetrics.metrics.ptPerEm;\n  var arraycolsep = 5 * pt; // \\arraycolsep in article.cls\n\n  // Vertical spacing\n  var baselineskip = 12 * pt; // see size10.clo\n  // Default \\arraystretch from lttab.dtx\n  // TODO(gagern): may get redefined once we have user-defined macros\n  var arraystretch = utils.deflt(group.value.arraystretch, 1);\n  var arrayskip = arraystretch * baselineskip;\n  var arstrutHeight = 0.7 * arrayskip; // \\strutbox in ltfsstrc.dtx and\n  var arstrutDepth = 0.3 * arrayskip; // \\@arstrutbox in lttab.dtx\n\n  var totalHeight = 0;\n  for (r = 0; r < group.value.body.length; ++r) {\n    var inrow = group.value.body[r];\n    var height = arstrutHeight; // \\@array adds an \\@arstrut\n    var depth = arstrutDepth; // to each tow (via the template)\n\n    if (nc < inrow.length) {\n      nc = inrow.length;\n    }\n    var outrow = new Array(inrow.length);\n    for (c = 0; c < inrow.length; ++c) {\n      var elt = buildGroup(inrow[c], options);\n      if (depth < elt.depth) {\n        depth = elt.depth;\n      }\n      if (height < elt.height) {\n        height = elt.height;\n      }\n      outrow[c] = elt;\n    }\n    var gap = 0;\n    if (group.value.rowGaps[r]) {\n      gap = group.value.rowGaps[r].value;\n      switch (gap.unit) {\n        case \"em\":\n          gap = gap.number;\n          break;\n        case \"ex\":\n          gap = gap.number * fontMetrics.metrics.emPerEx;\n          break;\n        default:\n          console.error(\"Can't handle unit \" + gap.unit);\n          gap = 0;\n      }\n      if (gap > 0) {\n        // \\@argarraycr\n        gap += arstrutDepth;\n        if (depth < gap) {\n          depth = gap; // \\@xargarraycr\n        }\n        gap = 0;\n      }\n    }\n    outrow.height = height;\n    outrow.depth = depth;\n    totalHeight += height;\n    outrow.pos = totalHeight;\n    totalHeight += depth + gap; // \\@yargarraycr\n    body[r] = outrow;\n  }\n  var offset = totalHeight / 2 + fontMetrics.metrics.axisHeight;\n  var colDescriptions = group.value.cols || [];\n  var cols = [];\n  var colSep;\n  var colDescrNum;\n  for (c = 0, colDescrNum = 0;\n  // Continue while either there are more columns or more column\n  // descriptions, so trailing separators don't get lost.\n  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {\n    var colDescr = colDescriptions[colDescrNum] || {};\n    var firstSeparator = true;\n    while (colDescr.type === \"separator\") {\n      // If there is more than one separator in a row, add a space\n      // between them.\n      if (!firstSeparator) {\n        colSep = makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = fontMetrics.metrics.doubleRuleSep + \"em\";\n        cols.push(colSep);\n      }\n      if (colDescr.separator === \"|\") {\n        var separator = makeSpan([\"vertical-separator\"], []);\n        separator.style.height = totalHeight + \"em\";\n        separator.style.verticalAlign = -(totalHeight - offset) + \"em\";\n        cols.push(separator);\n      } else {\n        throw new ParseError(\"Invalid separator type: \" + colDescr.separator);\n      }\n      colDescrNum++;\n      colDescr = colDescriptions[colDescrNum] || {};\n      firstSeparator = false;\n    }\n    if (c >= nc) {\n      continue;\n    }\n    var sepwidth;\n    if (c > 0 || group.value.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);\n      if (sepwidth !== 0) {\n        colSep = makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = sepwidth + \"em\";\n        cols.push(colSep);\n      }\n    }\n    var col = [];\n    for (r = 0; r < nr; ++r) {\n      var row = body[r];\n      var elem = row[c];\n      if (!elem) {\n        continue;\n      }\n      var shift = row.pos - offset;\n      elem.depth = row.depth;\n      elem.height = row.height;\n      col.push({\n        type: \"elem\",\n        elem: elem,\n        shift: shift\n      });\n    }\n    col = buildCommon.makeVList(col, \"individualShift\", null, options);\n    col = makeSpan([\"col-align-\" + (colDescr.align || \"c\")], [col]);\n    cols.push(col);\n    if (c < nc - 1 || group.value.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);\n      if (sepwidth !== 0) {\n        colSep = makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = sepwidth + \"em\";\n        cols.push(colSep);\n      }\n    }\n  }\n  body = makeSpan([\"mtable\"], cols);\n  return makeSpan([\"mord\"], [body], options.getColor());\n};\ngroupTypes.spacing = function (group, options, prev) {\n  if (group.value === \"\\\\ \" || group.value === \"\\\\space\" || group.value === \" \" || group.value === \"~\") {\n    // Spaces are generated by adding an actual space. Each of these\n    // things has an entry in the symbols table, so these will be turned\n    // into appropriate outputs.\n    return makeSpan([\"mord\", \"mspace\"], [buildCommon.mathsym(group.value, group.mode)]);\n  } else {\n    // Other kinds of spaces are of arbitrary width. We use CSS to\n    // generate these.\n    return makeSpan([\"mord\", \"mspace\", buildCommon.spacingFunctions[group.value].className]);\n  }\n};\ngroupTypes.llap = function (group, options, prev) {\n  var inner = makeSpan([\"inner\"], [buildGroup(group.value.body, options.reset())]);\n  var fix = makeSpan([\"fix\"], []);\n  return makeSpan([\"llap\", options.style.cls()], [inner, fix]);\n};\ngroupTypes.rlap = function (group, options, prev) {\n  var inner = makeSpan([\"inner\"], [buildGroup(group.value.body, options.reset())]);\n  var fix = makeSpan([\"fix\"], []);\n  return makeSpan([\"rlap\", options.style.cls()], [inner, fix]);\n};\ngroupTypes.op = function (group, options, prev) {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  if (group.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = group.value.sup;\n    subGroup = group.value.sub;\n    group = group.value.base;\n    hasLimits = true;\n  }\n\n  // Most operators have a large successor symbol, but these don't.\n  var noSuccessor = [\"\\\\smallint\"];\n  var large = false;\n  if (options.style.size === Style.DISPLAY.size && group.value.symbol && !utils.contains(noSuccessor, group.value.body)) {\n    // Most symbol operators get larger in displaystyle (rule 13)\n    large = true;\n  }\n  var base;\n  var baseShift = 0;\n  var slant = 0;\n  if (group.value.symbol) {\n    // If this is a symbol, create the symbol.\n    var style = large ? \"Size2-Regular\" : \"Size1-Regular\";\n    base = buildCommon.makeSymbol(group.value.body, style, \"math\", options.getColor(), [\"op-symbol\", large ? \"large-op\" : \"small-op\", \"mop\"]);\n\n    // Shift the symbol so its center lies on the axis (rule 13). It\n    // appears that our fonts have the centers of the symbols already\n    // almost on the axis, so these numbers are very small. Note we\n    // don't actually apply this here, but instead it is used either in\n    // the vlist creation or separately when there are no limits.\n    baseShift = (base.height - base.depth) / 2 - fontMetrics.metrics.axisHeight * options.style.sizeMultiplier;\n\n    // The slant of the symbol is just its italic correction.\n    slant = base.italic;\n  } else {\n    // Otherwise, this is a text operator. Build the text from the\n    // operator's name.\n    // TODO(emily): Add a space in the middle of some of these\n    // operators, like \\limsup\n    var output = [];\n    for (var i = 1; i < group.value.body.length; i++) {\n      output.push(buildCommon.mathsym(group.value.body[i], group.mode));\n    }\n    base = makeSpan([\"mop\"], output, options.getColor());\n  }\n  if (hasLimits) {\n    // IE 8 clips \\int if it is in a display: inline-block. We wrap it\n    // in a new span so it is an inline, and works.\n    base = makeSpan([], [base]);\n    var supmid;\n    var supKern;\n    var submid;\n    var subKern;\n    // We manually have to handle the superscripts and subscripts. This,\n    // aside from the kern calculations, is copied from supsub.\n    if (supGroup) {\n      var sup = buildGroup(supGroup, options.withStyle(options.style.sup()));\n      supmid = makeSpan([options.style.reset(), options.style.sup().cls()], [sup]);\n      supKern = Math.max(fontMetrics.metrics.bigOpSpacing1, fontMetrics.metrics.bigOpSpacing3 - sup.depth);\n    }\n    if (subGroup) {\n      var sub = buildGroup(subGroup, options.withStyle(options.style.sub()));\n      submid = makeSpan([options.style.reset(), options.style.sub().cls()], [sub]);\n      subKern = Math.max(fontMetrics.metrics.bigOpSpacing2, fontMetrics.metrics.bigOpSpacing4 - sub.height);\n    }\n\n    // Build the final group as a vlist of the possible subscript, base,\n    // and possible superscript.\n    var finalGroup;\n    var top;\n    var bottom;\n    if (!supGroup) {\n      top = base.height - baseShift;\n      finalGroup = buildCommon.makeVList([{\n        type: \"kern\",\n        size: fontMetrics.metrics.bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: submid\n      }, {\n        type: \"kern\",\n        size: subKern\n      }, {\n        type: \"elem\",\n        elem: base\n      }], \"top\", top, options);\n\n      // Here, we shift the limits by the slant of the symbol. Note\n      // that we are supposed to shift the limits by 1/2 of the slant,\n      // but since we are centering the limits adding a full slant of\n      // margin will shift by 1/2 that.\n      finalGroup.children[0].style.marginLeft = -slant + \"em\";\n    } else if (!subGroup) {\n      bottom = base.depth + baseShift;\n      finalGroup = buildCommon.makeVList([{\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: supKern\n      }, {\n        type: \"elem\",\n        elem: supmid\n      }, {\n        type: \"kern\",\n        size: fontMetrics.metrics.bigOpSpacing5\n      }], \"bottom\", bottom, options);\n\n      // See comment above about slants\n      finalGroup.children[1].style.marginLeft = slant + \"em\";\n    } else if (!supGroup && !subGroup) {\n      // This case probably shouldn't occur (this would mean the\n      // supsub was sending us a group with no superscript or\n      // subscript) but be safe.\n      return base;\n    } else {\n      bottom = fontMetrics.metrics.bigOpSpacing5 + submid.height + submid.depth + subKern + base.depth + baseShift;\n      finalGroup = buildCommon.makeVList([{\n        type: \"kern\",\n        size: fontMetrics.metrics.bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: submid\n      }, {\n        type: \"kern\",\n        size: subKern\n      }, {\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: supKern\n      }, {\n        type: \"elem\",\n        elem: supmid\n      }, {\n        type: \"kern\",\n        size: fontMetrics.metrics.bigOpSpacing5\n      }], \"bottom\", bottom, options);\n\n      // See comment above about slants\n      finalGroup.children[0].style.marginLeft = -slant + \"em\";\n      finalGroup.children[2].style.marginLeft = slant + \"em\";\n    }\n    return makeSpan([\"mop\", \"op-limits\"], [finalGroup]);\n  } else {\n    if (group.value.symbol) {\n      base.style.top = baseShift + \"em\";\n    }\n    return base;\n  }\n};\ngroupTypes.katex = function (group, options, prev) {\n  // The KaTeX logo. The offsets for the K and a were chosen to look\n  // good, but the offsets for the T, E, and X were taken from the\n  // definition of \\TeX in TeX (see TeXbook pg. 356)\n  var k = makeSpan([\"k\"], [buildCommon.mathsym(\"K\", group.mode)]);\n  var a = makeSpan([\"a\"], [buildCommon.mathsym(\"A\", group.mode)]);\n  a.height = (a.height + 0.2) * 0.75;\n  a.depth = (a.height - 0.2) * 0.75;\n  var t = makeSpan([\"t\"], [buildCommon.mathsym(\"T\", group.mode)]);\n  var e = makeSpan([\"e\"], [buildCommon.mathsym(\"E\", group.mode)]);\n  e.height = e.height - 0.2155;\n  e.depth = e.depth + 0.2155;\n  var x = makeSpan([\"x\"], [buildCommon.mathsym(\"X\", group.mode)]);\n  return makeSpan([\"katex-logo\", \"mord\"], [k, a, t, e, x], options.getColor());\n};\ngroupTypes.overline = function (group, options, prev) {\n  // Overlines are handled in the TeXbook pg 443, Rule 9.\n\n  // Build the inner group in the cramped style.\n  var innerGroup = buildGroup(group.value.body, options.withStyle(options.style.cramp()));\n  var ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;\n\n  // Create the line above the body\n  var line = makeSpan([options.style.reset(), Style.TEXT.cls(), \"overline-line\"]);\n  line.height = ruleWidth;\n  line.maxFontSize = 1.0;\n\n  // Generate the vlist, with the appropriate kerns\n  var vlist = buildCommon.makeVList([{\n    type: \"elem\",\n    elem: innerGroup\n  }, {\n    type: \"kern\",\n    size: 3 * ruleWidth\n  }, {\n    type: \"elem\",\n    elem: line\n  }, {\n    type: \"kern\",\n    size: ruleWidth\n  }], \"firstBaseline\", null, options);\n  return makeSpan([\"overline\", \"mord\"], [vlist], options.getColor());\n};\ngroupTypes.underline = function (group, options, prev) {\n  // Underlines are handled in the TeXbook pg 443, Rule 10.\n\n  // Build the inner group.\n  var innerGroup = buildGroup(group.value.body, options);\n  var ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;\n\n  // Create the line above the body\n  var line = makeSpan([options.style.reset(), Style.TEXT.cls(), \"underline-line\"]);\n  line.height = ruleWidth;\n  line.maxFontSize = 1.0;\n\n  // Generate the vlist, with the appropriate kerns\n  var vlist = buildCommon.makeVList([{\n    type: \"kern\",\n    size: ruleWidth\n  }, {\n    type: \"elem\",\n    elem: line\n  }, {\n    type: \"kern\",\n    size: 3 * ruleWidth\n  }, {\n    type: \"elem\",\n    elem: innerGroup\n  }], \"top\", innerGroup.height, options);\n  return makeSpan([\"underline\", \"mord\"], [vlist], options.getColor());\n};\ngroupTypes.sqrt = function (group, options, prev) {\n  // Square roots are handled in the TeXbook pg. 443, Rule 11.\n\n  // First, we do the same steps as in overline to build the inner group\n  // and line\n  var inner = buildGroup(group.value.body, options.withStyle(options.style.cramp()));\n  var ruleWidth = fontMetrics.metrics.defaultRuleThickness / options.style.sizeMultiplier;\n  var line = makeSpan([options.style.reset(), Style.TEXT.cls(), \"sqrt-line\"], [], options.getColor());\n  line.height = ruleWidth;\n  line.maxFontSize = 1.0;\n  var phi = ruleWidth;\n  if (options.style.id < Style.TEXT.id) {\n    phi = fontMetrics.metrics.xHeight;\n  }\n\n  // Calculate the clearance between the body and line\n  var lineClearance = ruleWidth + phi / 4;\n  var innerHeight = (inner.height + inner.depth) * options.style.sizeMultiplier;\n  var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;\n\n  // Create a \\surd delimiter of the required minimum size\n  var delim = makeSpan([\"sqrt-sign\"], [delimiter.customSizedDelim(\"\\\\surd\", minDelimiterHeight, false, options, group.mode)], options.getColor());\n  var delimDepth = delim.height + delim.depth - ruleWidth;\n\n  // Adjust the clearance based on the delimiter size\n  if (delimDepth > inner.height + inner.depth + lineClearance) {\n    lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;\n  }\n\n  // Shift the delimiter so that its top lines up with the top of the line\n  var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;\n  delim.style.top = delimShift + \"em\";\n  delim.height -= delimShift;\n  delim.depth += delimShift;\n\n  // We add a special case here, because even when `inner` is empty, we\n  // still get a line. So, we use a simple heuristic to decide if we\n  // should omit the body entirely. (note this doesn't work for something\n  // like `\\sqrt{\\rlap{x}}`, but if someone is doing that they deserve for\n  // it not to work.\n  var body;\n  if (inner.height === 0 && inner.depth === 0) {\n    body = makeSpan();\n  } else {\n    body = buildCommon.makeVList([{\n      type: \"elem\",\n      elem: inner\n    }, {\n      type: \"kern\",\n      size: lineClearance\n    }, {\n      type: \"elem\",\n      elem: line\n    }, {\n      type: \"kern\",\n      size: ruleWidth\n    }], \"firstBaseline\", null, options);\n  }\n  if (!group.value.index) {\n    return makeSpan([\"sqrt\", \"mord\"], [delim, body]);\n  } else {\n    // Handle the optional root index\n\n    // The index is always in scriptscript style\n    var root = buildGroup(group.value.index, options.withStyle(Style.SCRIPTSCRIPT));\n    var rootWrap = makeSpan([options.style.reset(), Style.SCRIPTSCRIPT.cls()], [root]);\n\n    // Figure out the height and depth of the inner part\n    var innerRootHeight = Math.max(delim.height, body.height);\n    var innerRootDepth = Math.max(delim.depth, body.depth);\n\n    // The amount the index is shifted by. This is taken from the TeX\n    // source, in the definition of `\\r@@t`.\n    var toShift = 0.6 * (innerRootHeight - innerRootDepth);\n\n    // Build a VList with the superscript shifted up correctly\n    var rootVList = buildCommon.makeVList([{\n      type: \"elem\",\n      elem: rootWrap\n    }], \"shift\", -toShift, options);\n    // Add a class surrounding it so we can add on the appropriate\n    // kerning\n    var rootVListWrap = makeSpan([\"root\"], [rootVList]);\n    return makeSpan([\"sqrt\", \"mord\"], [rootVListWrap, delim, body]);\n  }\n};\ngroupTypes.sizing = function (group, options, prev) {\n  // Handle sizing operators like \\Huge. Real TeX doesn't actually allow\n  // these functions inside of math expressions, so we do some special\n  // handling.\n  var inner = buildExpression(group.value.value, options.withSize(group.value.size), prev);\n  var span = makeSpan([\"mord\"], [makeSpan([\"sizing\", \"reset-\" + options.size, group.value.size, options.style.cls()], inner)]);\n\n  // Calculate the correct maxFontSize manually\n  var fontSize = buildCommon.sizingMultiplier[group.value.size];\n  span.maxFontSize = fontSize * options.style.sizeMultiplier;\n  return span;\n};\ngroupTypes.styling = function (group, options, prev) {\n  // Style changes are handled in the TeXbook on pg. 442, Rule 3.\n\n  // Figure out what style we're changing to.\n  var style = {\n    \"display\": Style.DISPLAY,\n    \"text\": Style.TEXT,\n    \"script\": Style.SCRIPT,\n    \"scriptscript\": Style.SCRIPTSCRIPT\n  };\n  var newStyle = style[group.value.style];\n\n  // Build the inner expression in the new style.\n  var inner = buildExpression(group.value.value, options.withStyle(newStyle), prev);\n  return makeSpan([options.style.reset(), newStyle.cls()], inner);\n};\ngroupTypes.font = function (group, options, prev) {\n  var font = group.value.font;\n  return buildGroup(group.value.body, options.withFont(font), prev);\n};\ngroupTypes.delimsizing = function (group, options, prev) {\n  var delim = group.value.value;\n  if (delim === \".\") {\n    // Empty delimiters still count as elements, even though they don't\n    // show anything.\n    return makeSpan([groupToType[group.value.delimType]]);\n  }\n\n  // Use delimiter.sizedDelim to generate the delimiter.\n  return makeSpan([groupToType[group.value.delimType]], [delimiter.sizedDelim(delim, group.value.size, options, group.mode)]);\n};\ngroupTypes.leftright = function (group, options, prev) {\n  // Build the inner expression\n  var inner = buildExpression(group.value.body, options.reset());\n  var innerHeight = 0;\n  var innerDepth = 0;\n\n  // Calculate its height and depth\n  for (var i = 0; i < inner.length; i++) {\n    innerHeight = Math.max(inner[i].height, innerHeight);\n    innerDepth = Math.max(inner[i].depth, innerDepth);\n  }\n\n  // The size of delimiters is the same, regardless of what style we are\n  // in. Thus, to correctly calculate the size of delimiter we need around\n  // a group, we scale down the inner size based on the size.\n  innerHeight *= options.style.sizeMultiplier;\n  innerDepth *= options.style.sizeMultiplier;\n  var leftDelim;\n  if (group.value.left === \".\") {\n    // Empty delimiters in \\left and \\right make null delimiter spaces.\n    leftDelim = makeNullDelimiter(options);\n  } else {\n    // Otherwise, use leftRightDelim to generate the correct sized\n    // delimiter.\n    leftDelim = delimiter.leftRightDelim(group.value.left, innerHeight, innerDepth, options, group.mode);\n  }\n  // Add it to the beginning of the expression\n  inner.unshift(leftDelim);\n  var rightDelim;\n  // Same for the right delimiter\n  if (group.value.right === \".\") {\n    rightDelim = makeNullDelimiter(options);\n  } else {\n    rightDelim = delimiter.leftRightDelim(group.value.right, innerHeight, innerDepth, options, group.mode);\n  }\n  // Add it to the end of the expression.\n  inner.push(rightDelim);\n  return makeSpan([\"minner\", options.style.cls()], inner, options.getColor());\n};\ngroupTypes.rule = function (group, options, prev) {\n  // Make an empty span for the rule\n  var rule = makeSpan([\"mord\", \"rule\"], [], options.getColor());\n\n  // Calculate the shift, width, and height of the rule, and account for units\n  var shift = 0;\n  if (group.value.shift) {\n    shift = group.value.shift.number;\n    if (group.value.shift.unit === \"ex\") {\n      shift *= fontMetrics.metrics.xHeight;\n    }\n  }\n  var width = group.value.width.number;\n  if (group.value.width.unit === \"ex\") {\n    width *= fontMetrics.metrics.xHeight;\n  }\n  var height = group.value.height.number;\n  if (group.value.height.unit === \"ex\") {\n    height *= fontMetrics.metrics.xHeight;\n  }\n\n  // The sizes of rules are absolute, so make it larger if we are in a\n  // smaller style.\n  shift /= options.style.sizeMultiplier;\n  width /= options.style.sizeMultiplier;\n  height /= options.style.sizeMultiplier;\n\n  // Style the rule to the right size\n  rule.style.borderRightWidth = width + \"em\";\n  rule.style.borderTopWidth = height + \"em\";\n  rule.style.bottom = shift + \"em\";\n\n  // Record the height and width\n  rule.width = width;\n  rule.height = height + shift;\n  rule.depth = -shift;\n  return rule;\n};\ngroupTypes.accent = function (group, options, prev) {\n  // Accents are handled in the TeXbook pg. 443, rule 12.\n  var base = group.value.base;\n  var supsubGroup;\n  if (group.type === \"supsub\") {\n    // If our base is a character box, and we have superscripts and\n    // subscripts, the supsub will defer to us. In particular, we want\n    // to attach the superscripts and subscripts to the inner body (so\n    // that the position of the superscripts and subscripts won't be\n    // affected by the height of the accent). We accomplish this by\n    // sticking the base of the accent into the base of the supsub, and\n    // rendering that, while keeping track of where the accent is.\n\n    // The supsub group is the group that was passed in\n    var supsub = group;\n    // The real accent group is the base of the supsub group\n    group = supsub.value.base;\n    // The character box is the base of the accent group\n    base = group.value.base;\n    // Stick the character box into the base of the supsub group\n    supsub.value.base = base;\n\n    // Rerender the supsub group with its new base, and store that\n    // result.\n    supsubGroup = buildGroup(supsub, options.reset(), prev);\n  }\n\n  // Build the base group\n  var body = buildGroup(base, options.withStyle(options.style.cramp()));\n\n  // Calculate the skew of the accent. This is based on the line \"If the\n  // nucleus is not a single character, let s = 0; otherwise set s to the\n  // kern amount for the nucleus followed by the \\skewchar of its font.\"\n  // Note that our skew metrics are just the kern between each character\n  // and the skewchar.\n  var skew;\n  if (isCharacterBox(base)) {\n    // If the base is a character box, then we want the skew of the\n    // innermost character. To do that, we find the innermost character:\n    var baseChar = getBaseElem(base);\n    // Then, we render its group to get the symbol inside it\n    var baseGroup = buildGroup(baseChar, options.withStyle(options.style.cramp()));\n    // Finally, we pull the skew off of the symbol.\n    skew = baseGroup.skew;\n    // Note that we now throw away baseGroup, because the layers we\n    // removed with getBaseElem might contain things like \\color which\n    // we can't get rid of.\n    // TODO(emily): Find a better way to get the skew\n  } else {\n    skew = 0;\n  }\n\n  // calculate the amount of space between the body and the accent\n  var clearance = Math.min(body.height, fontMetrics.metrics.xHeight);\n\n  // Build the accent\n  var accent = buildCommon.makeSymbol(group.value.accent, \"Main-Regular\", \"math\", options.getColor());\n  // Remove the italic correction of the accent, because it only serves to\n  // shift the accent over to a place we don't want.\n  accent.italic = 0;\n\n  // The \\vec character that the fonts use is a combining character, and\n  // thus shows up much too far to the left. To account for this, we add a\n  // specific class which shifts the accent over to where we want it.\n  // TODO(emily): Fix this in a better way, like by changing the font\n  var vecClass = group.value.accent === \"\\\\vec\" ? \"accent-vec\" : null;\n  var accentBody = makeSpan([\"accent-body\", vecClass], [makeSpan([], [accent])]);\n  accentBody = buildCommon.makeVList([{\n    type: \"elem\",\n    elem: body\n  }, {\n    type: \"kern\",\n    size: -clearance\n  }, {\n    type: \"elem\",\n    elem: accentBody\n  }], \"firstBaseline\", null, options);\n\n  // Shift the accent over by the skew. Note we shift by twice the skew\n  // because we are centering the accent, so by adding 2*skew to the left,\n  // we shift it to the right by 1*skew.\n  accentBody.children[1].style.marginLeft = 2 * skew + \"em\";\n  var accentWrap = makeSpan([\"mord\", \"accent\"], [accentBody]);\n  if (supsubGroup) {\n    // Here, we replace the \"base\" child of the supsub with our newly\n    // generated accent.\n    supsubGroup.children[0] = accentWrap;\n\n    // Since we don't rerun the height calculation after replacing the\n    // accent, we manually recalculate height.\n    supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);\n\n    // Accents should always be ords, even when their innards are not.\n    supsubGroup.classes[0] = \"mord\";\n    return supsubGroup;\n  } else {\n    return accentWrap;\n  }\n};\ngroupTypes.phantom = function (group, options, prev) {\n  var elements = buildExpression(group.value.value, options.withPhantom(), prev);\n\n  // \\phantom isn't supposed to affect the elements it contains.\n  // See \"color\" for more details.\n  return new buildCommon.makeFragment(elements);\n};\n\n/**\n * buildGroup is the function that takes a group and calls the correct groupType\n * function for it. It also handles the interaction of size and style changes\n * between parents and children.\n */\nvar buildGroup = function buildGroup(group, options, prev) {\n  if (!group) {\n    return makeSpan();\n  }\n  if (groupTypes[group.type]) {\n    // Call the groupTypes function\n    var groupNode = groupTypes[group.type](group, options, prev);\n    var multiplier;\n\n    // If the style changed between the parent and the current group,\n    // account for the size difference\n    if (options.style !== options.parentStyle) {\n      multiplier = options.style.sizeMultiplier / options.parentStyle.sizeMultiplier;\n      groupNode.height *= multiplier;\n      groupNode.depth *= multiplier;\n    }\n\n    // If the size changed between the parent and the current group, account\n    // for that size difference.\n    if (options.size !== options.parentSize) {\n      multiplier = buildCommon.sizingMultiplier[options.size] / buildCommon.sizingMultiplier[options.parentSize];\n      groupNode.height *= multiplier;\n      groupNode.depth *= multiplier;\n    }\n    return groupNode;\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n\n/**\n * Take an entire parse tree, and build it into an appropriate set of HTML\n * nodes.\n */\nvar buildHTML = function buildHTML(tree, options) {\n  // buildExpression is destructive, so we need to make a clone\n  // of the incoming tree so that it isn't accidentally changed\n  tree = JSON.parse(JSON.stringify(tree));\n\n  // Build the expression contained in the tree\n  var expression = buildExpression(tree, options);\n  var body = makeSpan([\"base\", options.style.cls()], expression);\n\n  // Add struts, which ensure that the top of the HTML element falls at the\n  // height of the expression, and the bottom of the HTML element falls at the\n  // depth of the expression.\n  var topStrut = makeSpan([\"strut\"]);\n  var bottomStrut = makeSpan([\"strut\", \"bottom\"]);\n  topStrut.style.height = body.height + \"em\";\n  bottomStrut.style.height = body.height + body.depth + \"em\";\n  // We'd like to use `vertical-align: top` but in IE 9 this lowers the\n  // baseline of the box to the bottom of this strut (instead staying in the\n  // normal place) so we use an absolute value for vertical-align instead\n  bottomStrut.style.verticalAlign = -body.depth + \"em\";\n\n  // Wrap the struts and body together\n  var htmlNode = makeSpan([\"katex-html\"], [topStrut, bottomStrut, body]);\n  htmlNode.setAttribute(\"aria-hidden\", \"true\");\n  return htmlNode;\n};\nmodule.exports = buildHTML;","map":null,"metadata":{},"sourceType":"script"}