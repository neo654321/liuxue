{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\n/* eslint no-constant-condition:0 */\nvar fontMetrics = require(\"./fontMetrics\");\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\nvar ParseNode = parseData.ParseNode;\n\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.\n */\nfunction parseArray(parser, result) {\n  var row = [];\n  var body = [row];\n  var rowGaps = [];\n  while (true) {\n    var cell = parser.parseExpression(false, null);\n    row.push(new ParseNode(\"ordgroup\", cell, parser.mode));\n    var next = parser.nextToken.text;\n    if (next === \"&\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      break;\n    } else if (next === \"\\\\\\\\\" || next === \"\\\\cr\") {\n      var cr = parser.parseFunction();\n      rowGaps.push(cr.value.size);\n      row = [];\n      body.push(row);\n    } else {\n      // TODO: Clean up the following hack once #385 got merged\n      var pos = Math.min(parser.pos + 1, parser.lexer._input.length);\n      throw new ParseError(\"Expected & or \\\\\\\\ or \\\\end\", parser.lexer, pos);\n    }\n  }\n  result.body = body;\n  result.rowGaps = rowGaps;\n  return new ParseNode(result.type, result, parser.mode);\n}\n\n/*\n * An environment definition is very similar to a function definition:\n * it is declared with a name or a list of names, a set of properties\n * and a handler containing the actual implementation.\n *\n * The properties include:\n *  - numArgs: The number of arguments after the \\begin{name} function.\n *  - argTypes: (optional) Just like for a function\n *  - allowedInText: (optional) Whether or not the environment is allowed inside\n *                   text mode (default false) (not enforced yet)\n *  - numOptionalArgs: (optional) Just like for a function\n * A bare number instead of that object indicates the numArgs value.\n *\n * The handler function will receive two arguments\n *  - context: information and references provided by the parser\n *  - args: an array of arguments passed to \\begin{name}\n * The context contains the following properties:\n *  - envName: the name of the environment, one of the listed names.\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions associated with these arguments from args.\n * The handler must return a ParseResult.\n */\n\nfunction defineEnvironment(names, props, handler) {\n  if (typeof names === \"string\") {\n    names = [names];\n  }\n  if (typeof props === \"number\") {\n    props = {\n      numArgs: props\n    };\n  }\n  // Set default values of environments\n  var data = {\n    numArgs: props.numArgs || 0,\n    argTypes: props.argTypes,\n    greediness: 1,\n    allowedInText: !!props.allowedInText,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    handler: handler\n  };\n  for (var i = 0; i < names.length; ++i) {\n    module.exports[names[i]] = data;\n  }\n}\n\n// Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\ndefineEnvironment(\"array\", {\n  numArgs: 1\n}, function (context, args) {\n  var colalign = args[0];\n  colalign = colalign.value.map ? colalign.value : [colalign];\n  var cols = colalign.map(function (node) {\n    var ca = node.value;\n    if (\"lcr\".indexOf(ca) !== -1) {\n      return {\n        type: \"align\",\n        align: ca\n      };\n    } else if (ca === \"|\") {\n      return {\n        type: \"separator\",\n        separator: \"|\"\n      };\n    }\n    throw new ParseError(\"Unknown column alignment: \" + node.value, context.lexer, context.positions[1]);\n  });\n  var res = {\n    type: \"array\",\n    cols: cols,\n    hskipBeforeAndAfter: true // \\@preamble in lttab.dtx\n  };\n  res = parseArray(context.parser, res);\n  return res;\n});\n\n// The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\ndefineEnvironment([\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\"], {}, function (context) {\n  var delimiters = {\n    \"matrix\": null,\n    \"pmatrix\": [\"(\", \")\"],\n    \"bmatrix\": [\"[\", \"]\"],\n    \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n    \"vmatrix\": [\"|\", \"|\"],\n    \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n  }[context.envName];\n  var res = {\n    type: \"array\",\n    hskipBeforeAndAfter: false // \\hskip -\\arraycolsep in amsmath\n  };\n  res = parseArray(context.parser, res);\n  if (delimiters) {\n    res = new ParseNode(\"leftright\", {\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1]\n    }, context.mode);\n  }\n  return res;\n});\n\n// A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}} â€¦ \\end{array}\\right.\ndefineEnvironment(\"cases\", {}, function (context) {\n  var res = {\n    type: \"array\",\n    arraystretch: 1.2,\n    cols: [{\n      type: \"align\",\n      align: \"l\",\n      pregap: 0,\n      postgap: fontMetrics.metrics.quad\n    }, {\n      type: \"align\",\n      align: \"l\",\n      pregap: 0,\n      postgap: 0\n    }]\n  };\n  res = parseArray(context.parser, res);\n  res = new ParseNode(\"leftright\", {\n    body: [res],\n    left: \"\\\\{\",\n    right: \".\"\n  }, context.mode);\n  return res;\n});\n\n// An aligned environment is like the align* environment\n// except it operates within math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\ndefineEnvironment(\"aligned\", {}, function (context) {\n  var res = {\n    type: \"array\",\n    cols: []\n  };\n  res = parseArray(context.parser, res);\n  var emptyGroup = new ParseNode(\"ordgroup\", [], context.mode);\n  var numCols = 0;\n  res.value.body.forEach(function (row) {\n    var i;\n    for (i = 1; i < row.length; i += 2) {\n      row[i].value.unshift(emptyGroup);\n    }\n    if (numCols < row.length) {\n      numCols = row.length;\n    }\n  });\n  for (var i = 0; i < numCols; ++i) {\n    var align = \"r\";\n    var pregap = 0;\n    if (i % 2 === 1) {\n      align = \"l\";\n    } else if (i > 0) {\n      pregap = 2; // one \\qquad between columns\n    }\n    res.value.cols[i] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n  return res;\n});","map":null,"metadata":{},"sourceType":"script"}